//------------ gles code
const char* gles_admodel_fragment = 
                             "/* admodel.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.4, 0.4, 0.4, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.6, 0.6, 0.6, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float error;\n"
                             "\n"
                             "uniform float sceneBottom;\n"
                             "uniform float sceneTop;\n"
                             "uniform sampler1D shapeTexture;\n"
                             "\n"
                             "uniform int fanzhuan = 0;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform vec4 stateColors[5];\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower);\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "vec4 changeColor(vec3 wordPos)\n"
                             "{\n"
                             "	float delta = sceneTop - sceneBottom;\n"
                             "	if(delta < 1.0)\n"
                             "		delta = 1.0;\n"
                             "	\n"
                             "	float texCoord = (wordPos.z - sceneBottom)/delta;\n"
                             "	return texture(shapeTexture, texCoord);\n"
                             "	//return vec4(texCoord, 0.0, 0.0, 1.0);\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec4 color = stateColors[int(state)];	\n"
                             "	if(error == 1.0)\n"
                             "		color = stateColors[3];\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = ambient;\n"
                             "	vec4 diffuse_color    = diffuse;\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec4 coreColor = directLight(lightDirection, fnormal, color, ambient_color, diffuse_color, specular_color);\n"
                             "	if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "	{\n"
                             "		coreColor.g += 0.4;\n"
                             "	}\n"
                             "	\n"
                             "	coreColor += changeColor(worldPosition);\n"
                             "	\n"
                             "	int fz = fanzhuan % 2;\n"
                             "	\n"
                             "	if(fz == 0)\n"
                             "	{\n"
                             "		if(!gl_FrontFacing)\n"
                             "		{\n"
                             "			coreColor.rgb = vec3(0.65, 0.75, 0.65) - coreColor.rgb;\n"
                             "		}\n"
                             "	}\n"
                             "	else\n"
                             "	{\n"
                             "		if(gl_FrontFacing)\n"
                             "		{\n"
                             "			coreColor.rgb = vec3(0.65, 0.75, 0.65) - coreColor.rgb;\n"
                             "		}\n"
                             "	}\n"
                             "   \n"
                             "	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_admodel_vert = 
                             "/* admodel.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix  = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition   = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position           = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirection         = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix     = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normal          	  = normalMatrix * vertexNormal;\n"
                             "    worldPosition   	  = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* gles_bottomface_fragment = 
                             "/* bottomface.fragment */\n"
                             "precision mediump float;\n"
                             "varying vec3 normal;\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	vec4 finalcolor = color;\n"
                             "\n"
                             "	vec3 fgnormal 		  =	normalize(normal);\n"
                             "	if(dot(fgnormal, vec3(0.0, 0.0, -1.0)) > 0.0)\n"
                             "	{\n"
                             "		finalcolor.a = 0.0;\n"
                             "	}\n"
                             "	gl_FragColor = finalcolor;\n"
                             "	\n"
                             "}\n"
;
const char* gles_bottomface_vert = 
                             "/* bottomface.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec2 texcoord;\n"
                             "varying vec3 normal;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "   \n"
                             "   mat3 normalMatrix = mat3(viewMatrix);\n"
                             "   normal          = normalMatrix * vertexNormal;\n"
                             "}\n"
;
const char* gles_boxclippure_fragment = 
                             "/* boxclippure.fragment */\n"
                             "\n"
                             "varying vec3 worldPosition;\n"
                             "uniform vec4 color;\n"
                             "uniform vec3 clip[2];\n"
                             "\n"
                             "uniform float intensity = 5.0;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	gl_FragColor = color;\n"
                             "	#if 0\n"
                             "	if ( worldPosition.z < clip[0].z || worldPosition.z > clip[1].z\n"
                             "        || worldPosition.x < clip[0].x || worldPosition.x > clip[1].x\n"
                             "        || worldPosition.y < clip[0].y || worldPosition.y > clip[1].y) \n"
                             "	{\n"
                             "		discard;\n"
                             "	} else {\n"
                             "	\n"
                             "		float x = min( abs(worldPosition.x - clip[0].x), abs(worldPosition.x - clip[1].x) );\n"
                             "		float y = min( abs(worldPosition.y - clip[0].y), abs(worldPosition.y - clip[1].y) );\n"
                             "		float z = min( abs(worldPosition.z - clip[0].z), abs(worldPosition.z - clip[1].z) );\n"
                             "		\n"
                             "		x = min(x, y);\n"
                             "		x = min(x, z);\n"
                             "\n"
                             "		float k = clamp(x * intensity, 0.0, 1.0);\n"
                             "		gl_FragColor = vec4(color.rgb, color.a * k);\n"
                             "	}\n"
                             "	#endif\n"
                             "}\n"
;
const char* gles_boxclippure_vert = 
                             "/* boxclippure.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* gles_chunk_fragment = 
                             "/* chunk.fragment */\n"
                             "\n"
                             "uniform vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n"
                             "varying float flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(flag == 0.0)\n"
                             "		discard;	\n"
                             "\n"
                             "	gl_FragColor = color;\n"
                             "}\n"
;
const char* gles_chunk_vert = 
                             "/* chunk.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "attribute float vertexFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying float flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	flag			= vertexFlag;\n"
                             "}\n"
;
const char* gles_color_fragment = 
                             "/* color.fragment */\n"
                             "\n"
                             "varying vec4 fcolor;\n"
                             "void main() \n"
                             "{\n"
                             "	gl_FragColor = fcolor;\n"
                             "}\n"
;
const char* gles_color_vert = 
                             "/* color.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec4 vertexColor;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "varying vec4 fcolor;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "   fcolor = vertexColor;\n"
                             "}\n"
;
const char* gles_dlpsupportindicator_fragment = 
                             "/* DlpSupportIndicator Fragment*/\n"
                             "precision mediump float; \n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "const vec4 ambient = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "const vec4 diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "const vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "const float specularPower = 12.0;\n"
                             "\n"
                             "const vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	float NdotL 		  = dot(fnormal, lightDirection);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - lightDirection);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;	\n"
                             "	\n"
                             "    gl_FragColor = vec4(coreColor.rgb, color.a);\n"
                             "}\n"
                             "\n"
;
const char* gles_dlpsupportindicator_vert = 
                             "/* DlpSupportIndicator Vertex*/\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* gles_finephong_fragment = 
                             "/* finephong.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "\n"
                             "uniform vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform float specularPower = 128.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec4 _color			  = color;\n"
                             "	if(!gl_FrontFacing)\n"
                             "    {\n"
                             "		_color = vec4(0.65, 0.0, 0.0, 1.0);\n"
                             "    }\n"
                             "	\n"
                             "	float NdotL 		  = max(dot(fnormal, lightDirection), 0.0);\n"
                             "	vec4 ambientColor 	  = ambient * _color;\n"
                             "	vec3 freflection      = reflect(-lightDirection, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * _color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_finephong_vert = 
                             "/* finephong.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 worldPosition = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  worldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-worldPosition));\n"
                             "    normal          = mat3(modelview_matrix) * vertexNormal;\n"
                             "}\n"
;
const char* gles_finephongtex_fragment = 
                             "/* finephongtex.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec2 texcoord;\n"
                             "\n"
                             "uniform sampler2D shapeTexture;\n"
                             "\n"
                             "uniform vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform float specularPower = 128.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform float useAzi = 0.0;\n"
                             "\n"
                             "vec2 azi_to_equ(vec2 tc)\n"
                             "{\n"
                             "	vec2 zaiTC = tc;\n"
                             "	if(useAzi == 1.0)\n"
                             "	{\n"
                             "		float PI = 3.1415926;\n"
                             "		vec2 t = vec2(tc.x - 0.5, tc.y - 0.5);\n"
                             "		float alpha = atan(t.y, t.x);\n"
                             "		float r = length(t);\n"
                             "		if(r > 0.5)\n"
                             "			zaiTC = vec2(-1.0, -1.0);\n"
                             "		else\n"
                             "		{\n"
                             "			float beta = 2 * PI * r;\n"
                             "			float x_ = 0.5 + 0.5 * alpha / PI;\n"
                             "			float y_= 1 - beta / PI;\n"
                             "			zaiTC = vec2(x_, y_);\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	return zaiTC;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec4 _color			  = color * texture2D(shapeTexture, azi_to_equ(texcoord));\n"
                             "	if(!gl_FrontFacing)\n"
                             "    {\n"
                             "		_color = vec4(0.65, 0.0, 0.0, 1.0);\n"
                             "    }\n"
                             "	\n"
                             "	float NdotL 		  = max(dot(fnormal, lightDirection), 0.0);\n"
                             "	vec4 ambientColor 	  = ambient * _color;\n"
                             "	vec3 freflection      = reflect(-lightDirection, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * _color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_finephongtex_vert = 
                             "/* finephongtex.vert */\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "attribute vec2 vertexTexcoord;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec2 texcoord;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 worldPosition = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  worldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-worldPosition));\n"
                             "    normal          = mat3(modelview_matrix) * vertexNormal;\n"
                             "	texcoord = vertexTexcoord;\n"
                             "}\n"
;
const char* gles_glcomp1_fragment = 
                             "/* glcomp1.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 gnormal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection));\n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec3 fgnormal 		  =	normalize(gnormal);\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "\n"
                             "	if(!gl_FrontFacing)\n"
                             "	{\n"
                             "		color = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "		fnormal = - fnormal;\n"
                             "	}\n"
                             "	\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient, diffuse, specular);\n"
                             "	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_glcomp1_vert = 
                             "/* glcomp1.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 gnormal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "    gnormal        = mat3(modelMatrix) * vertexNormal;\n"
                             "		\n"
                             "    worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* gles_manipulate_fragment = 
                             "/* manipulate.fragment */\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "uniform vec4 changecolor;\n"
                             "uniform int mt;\n"
                             "\n"
                             "uniform float state;\n"
                             "void main() \n"
                             "{\n"
                             "	if(mt == 0)\n"
                             "	{\n"
                             "		gl_FragColor = color * state;\n"
                             "	}\n"
                             "	else if(mt == 1)\n"
                             "	{\n"
                             "		gl_FragColor = color + changecolor * state;\n"
                             "	}\n"
                             "	\n"
                             "}\n"
;
const char* gles_manipulate_vert = 
                             "/* manipulate.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "}\n"
;
const char* gles_model_fragment = 
                             "/* model.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 gnormal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying vec3 worldWater;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform int lightingEnable = 1;\n"
                             "uniform float transparency = 1.0;\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "uniform float error;\n"
                             "uniform float supportCos = 0.5;\n"
                             "\n"
                             "uniform int hoverState = 0;\n"
                             "uniform int waterState = 0;\n"
                             "uniform int fanzhuan = 0;\n"
                             "uniform int checkscope = 1;\n"
                             "\n"
                             "uniform float zcha = 0.01;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform float nozzle;\n"
                             "uniform vec4 stateColors[6];\n"
                             "uniform vec4 customColor;\n"
                             "\n"
                             "bool frontFacing()\n"
                             "{\n"
                             "        vec3 fdx = dFdx(worldPosition);\n"
                             "        vec3 fdy = dFdy(worldPosition);\n"
                             "        return dot(gnormal, cross(fdx, fdy)) > 0.0;\n"
                             "} \n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return lightingEnable * (ambient_color + diffuse_color + specular_color) + (1 - lightingEnable) * core_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(checkscope > 0 && (worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight))\n"
                             "		discard;\n"
                             "\n"
                             "	int stateInt = int(state);\n"
                             "	vec4 color;\n"
                             "	if (stateInt < 5)\n"
                             "		color = stateColors[stateInt];\n"
                             "	else\n"
                             "		color = customColor;\n"
                             "	\n"
                             "	if(error == 1.0)\n"
                             "		color = stateColors[3];	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = ambient;\n"
                             "	vec4 diffuse_color    = diffuse;\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient_color, diffuse_color, specular_color);\n"
                             "	\n"
                             "	vec3 fgnormal 		  =	normalize(gnormal);\n"
                             "	\n"
                             "	if(checkscope > 0)\n"
                             "	{\n"
                             "		if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "		if( abs(worldPosition.z - bottom) < 0.05 )\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	\n"
                             "	if(hoverState > 0)\n"
                             "	{\n"
                             "		float v = dot(fgnormal, vec3(0.0, 0.0, -1.0));\n"
                             "		if(v >= supportCos)\n"
                             "		{\n"
                             "			coreColor.r += 0.8 * v;\n"
                             "		}\n"
                             "		\n"
                             "		if(waterState == 1)\n"
                             "		{\n"
                             "			if(abs(worldPosition.z - worldWater.z) < zcha)\n"
                             "			{\n"
                             "				coreColor = vec4(0.1, 0.1, 0.1, 1.0);\n"
                             "			}\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	coreColor.rgb = coreColor.rgb + vec3(0.1, -0.1, 0.0) * nozzle;\n"
                             "\n"
                             "	if(!frontFacing())\n"
                             "	{\n"
                             "		color = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "		color.a = 1.0;\n"
                             "		vec3 fbnormal = -fnormal;\n"
                             "		vec4 ambient_color_t 	  = ambient + vec4(0.03, 0.03, 0.03, 0.0);\n"
                             "		vec4 diffuse_color_t    = diffuse;\n"
                             "		vec4 specular_color_t   = specular;\n"
                             "		coreColor = directLight(lightDir, fbnormal, color, ambient_color_t, diffuse_color_t, specular_color_t);\n"
                             "	}\n"
                             "\n"
                             "    //int fz = fanzhuan % 2;\n"
                             "    //   \n"
                             "    //if(fz == 0)\n"
                             "    //{\n"
                             "    //    if(! frontFacing())\n"
                             "    //    {\n"
                             "    //        //coreColor = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "	//		coreColor.a = 1.0;\n"
                             "    //    }\n"
                             "    //}\n"
                             "    //else\n"
                             "    //{\n"
                             "    //    if(frontFacing())\n"
                             "    //    {\n"
                             "    //        //coreColor = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "	//		coreColor.a = 1.0;\n"
                             "    //    }\n"
                             "    //}\n"
                             "\n"
                             "	gl_FragColor = vec4(coreColor.rgb, transparency);\n"
                             "}\n"
;
const char* gles_model_vert = 
                             "/* model.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform vec3 water;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 gnormal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying vec3  worldWater;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "    gnormal        = mat3(modelMatrix) * vertexNormal;\n"
                             "		\n"
                             "    worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "    worldWater = water;\n"
                             "}\n"
;
const char* gles_modeldlp_fragment = 
                             "/* modeldlp.fragment */\n"
                             "precision mediump float;\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 gnormal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "uniform int state;\n"
                             "uniform float error;\n"
                             "\n"
                             "const vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "const vec4 diffuse = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "const vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "const float specularPower = 12.0;\n"
                             "const vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 clipPlane1;\n"
                             "uniform vec4 clipPlane2;\n"
                             "\n"
                             "const int checkScope = 1;\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "const float supportCos = 0.5;\n"
                             "\n"
                             "const int hoverState = 0;\n"
                             "const int waterState = 0;\n"
                             "\n"
                             "const float zcha = 0.1;\n"
                             "\n"
                             "uniform vec4 stateColors[6];\n"
                             "uniform vec3 water;\n"
                             "\n"
                             "float distance2Plane(vec3 position, vec4 plane)\n"
                             "{\n"
                             "	vec3 p = position - vec3(0.0, 0.0, plane.w);\n"
                             "	return dot(p, plane.xyz);\n"
                             "}\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(distance2Plane(worldPosition, clipPlane1) < 0.0)\n"
                             "		discard;\n"
                             "\n"
                             "	if(distance2Plane(worldPosition, clipPlane2) < 0.0)\n"
                             "		discard;\n"
                             "		\n"
                             "	vec4 color = stateColors[state];\n"
                             "	color = error * stateColors[3] + (1.0 - error) * color;	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec3 fgnormal 		  =	normalize(gnormal);\n"
                             "		\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "\n"
                             "	if(!gl_FrontFacing)\n"
                             "	{\n"
                             "		color = vec4(stateColors[5].xyz, 1.0);\n"
                             "		fnormal = - fnormal;\n"
                             "	}\n"
                             "	\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient, diffuse, specular);	\n"
                             "	if(checkScope > 0)\n"
                             "	{\n"
                             "		if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < 0.1 || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	\n"
                             "	if(hoverState > 0)\n"
                             "	{\n"
                             "		float v = dot(fgnormal, vec3(0.0, 0.0, -1.0));\n"
                             "		if(v >= supportCos)\n"
                             "		{\n"
                             "			coreColor.r += 0.8 * v;\n"
                             "		}\n"
                             "		\n"
                             "		if(waterState == 1)\n"
                             "		{\n"
                             "			if(abs(worldPosition.z - water.z) < zcha)\n"
                             "			{\n"
                             "				coreColor = vec4(0.1, 0.1, 0.1, 1.0);\n"
                             "			}\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_modeldlp_vert = 
                             "/* modeldlp.vert */\n"
                             "\n"
                             "attribute vec4 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 gnormal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying vec3  worldWater;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition.xyz, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "    gnormal        = mat3(modelMatrix) * vertexNormal;\n"
                             "		\n"
                             "    worldPosition   = vec3(modelMatrix * vec4(vertexPosition.xyz, 1.0));\n"
                             "}\n"
;
const char* gles_modelline_fragment = 
                             "/* modelline.fragment */\n"
                             "\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "uniform vec3 machineCube;\n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "uniform float error;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform vec4 stateColors[5];\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight)\n"
                             "		discard;\n"
                             "\n"
                             "	vec4 color = stateColors[int(state)];	\n"
                             "	//if(abs(worldPosition.x) > machineCube.x/2.0 || abs(worldPosition.y) > machineCube.y/2.0 ||  worldPosition.z > machineCube.z || worldPosition.z < 0.0)\n"
                             "    //   color = stateColors[3];\n"
                             "	if(error == 1.0)\n"
                             "		color = stateColors[3];\n"
                             "	\n"
                             "	gl_FragColor = vec4(0.1, 0.1, 0.1, 1.0);\n"
                             "}\n"
;
const char* gles_modelline_vert = 
                             "/* modelline.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* gles_modelselect_fragment = 
                             "/* modelselect.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.4, 0.4, 0.4, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.6, 0.6, 0.6, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "uniform float error;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform float nozzle;\n"
                             "uniform vec4 stateColors[4];\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower);\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight)\n"
                             "		discard;\n"
                             "\n"
                             "	vec4 color = stateColors[int(state)];	\n"
                             "	if(error == 1.0)\n"
                             "		color = stateColors[3];\n"
                             "		\n"
                             "	vec4 back_color = color;\n"
                             "//	back_color.rgb = vec3(1.0, 1.0, 1.0) - back_color.rgb;\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = ambient;\n"
                             "	vec4 diffuse_color    = diffuse;\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec4 coreColor = directLight(lightDirection, fnormal, color, ambient_color, diffuse_color, specular_color);\n"
                             "	vec4 coreColor_b = directLight(lightDirection, -fnormal, back_color, ambient_color - vec4(0.2, 0.2, 0.2, 0.0), diffuse_color, specular_color);\n"
                             "	\n"
                             "	coreColor.g += 0.4;\n"
                             "	coreColor.r += 0.4;\n"
                             "	\n"
                             "	coreColor_b.g += 0.2;\n"
                             "	coreColor_b.r += 0.2;\n"
                             "	\n"
                             "	coreColor.rgb = coreColor.rgb + vec3(0.1, -0.1, 0.0) * nozzle;\n"
                             "	coreColor_b.rgb = coreColor_b.rgb + vec3(0.1, -0.1, 0.0) * nozzle;\n"
                             "	\n"
                             "	if(gl_FrontFacing)\n"
                             "    {\n"
                             "        gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "    }\n"
                             "    else\n"
                             "    {\n"
                             "        gl_FragColor = vec4(coreColor_b.rgb, 0.4);\n"
                             "    }\n"
                             "	\n"
                             "//	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_modelselect_vert = 
                             "/* modelselect.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* gles_modelsimple_fragment = 
                             "/* ModelSimple Fragment*/\n"
                             "precision mediump float; \n"
                             "\n"
                             "/*noperspective*/ varying  vec3 viewDirection;\n"
                             "/*noperspective*/ varying  vec3 normal;\n"
                             "\n"
                             "const vec4 ambient = vec4(0.4, 0.4, 0.4, 1.0);\n"
                             "const vec4 diffuse = vec4(0.6, 0.6, 0.6, 1.0);\n"
                             "const vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "const float specularPower = 12.0;\n"
                             "\n"
                             "const vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "const vec4 stateColors = vec4(0.8, 0.5, 0.8, 1.0);\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec4 color = stateColors;	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	float NdotL 		  = max(dot(fnormal, lightDirection), 0.0);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = reflect(-lightDirection, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	\n"
                             "	gl_FragColor = vec4(coreColor.rgb, 0.8);\n"
                             "}\n"
;
const char* gles_modelsimple_vert = 
                             "/* ModelSimple Vertex*/\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "/*noperspective*/ varying vec3 viewDirection;\n"
                             "/*noperspective*/ varying vec3 normal;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "}\n"
;
const char* gles_modelSupport_fragment = 
                             "/* modelSupport.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "flat varying vec3 gnormal;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "uniform vec4 diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "uniform float supportCos = 0.707;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform vec4 stateColors[4];\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec4 color = stateColors[int(state)];	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec3 fgnormal		  = normalize(gnormal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	if(dot(fgnormal, vec3(0.0, 0.0, -1.0)) > supportCos)\n"
                             "		color = stateColors[3];\n"
                             "		\n"
                             "	float NdotL 		  = max(dot(fnormal, lightDirection), 0.0);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = reflect(-lightDirection, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_modelSupport_vert = 
                             "/* modelSupport.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "flat varying vec3 gnormal;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "	\n"
                             "	gnormal			= mat3(modelMatrix) * vertexNormal;\n"
                             "}\n"
;
const char* gles_modelwireframe_fragment = 
                             "/* modelwireframe.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 gnormal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying vec3 worldWater;\n"
                             "varying vec3 barycentric;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform int lightingEnable = 1;\n"
                             "uniform float transparency = 1.0;\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "uniform float error;\n"
                             "uniform float supportCos = 0.5;\n"
                             "\n"
                             "uniform int hoverState = 0;\n"
                             "uniform int waterState = 0;\n"
                             "uniform int fanzhuan = 0;\n"
                             "uniform int checkscope = 1;\n"
                             "\n"
                             "uniform float zcha = 0.01;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform float nozzle;\n"
                             "uniform vec4 stateColors[6];\n"
                             "uniform vec4 customColor;\n"
                             "\n"
                             "uniform vec3 wireframeColor = vec3(0.1);\n"
                             "uniform vec3 clearColor = vec3(0.27);\n"
                             "uniform int renderModel = 1;\n"
                             "\n"
                             "bool frontFacing()\n"
                             "{\n"
                             "        vec3 fdx = dFdx(worldPosition);\n"
                             "        vec3 fdy = dFdy(worldPosition);\n"
                             "        return dot(gnormal, cross(fdx, fdy)) > 0.0;\n"
                             "} \n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return lightingEnable * (ambient_color + diffuse_color + specular_color) + (1 - lightingEnable) * core_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(checkscope > 0 && (worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight))\n"
                             "		discard;\n"
                             "\n"
                             "	int stateInt = int(state);\n"
                             "	vec4 color;\n"
                             "	if (stateInt < 5)\n"
                             "		color = stateColors[stateInt];\n"
                             "	else\n"
                             "		color = customColor;\n"
                             "	\n"
                             "	if(error == 1.0)\n"
                             "		color = stateColors[3];	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = ambient;\n"
                             "	vec4 diffuse_color    = diffuse;\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient_color, diffuse_color, specular_color);\n"
                             "	\n"
                             "	vec3 fgnormal 		  =	normalize(gnormal);\n"
                             "	\n"
                             "	if(checkscope > 0)\n"
                             "	{\n"
                             "		if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "		if( abs(worldPosition.z - bottom) < 0.05 )\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	\n"
                             "	if(hoverState > 0)\n"
                             "	{\n"
                             "		float v = dot(fgnormal, vec3(0.0, 0.0, -1.0));\n"
                             "		if(v >= supportCos)\n"
                             "		{\n"
                             "			coreColor.r += 0.8 * v;\n"
                             "		}\n"
                             "		\n"
                             "		if(waterState == 1)\n"
                             "		{\n"
                             "			if(abs(worldPosition.z - worldWater.z) < zcha)\n"
                             "			{\n"
                             "				coreColor = vec4(0.1, 0.1, 0.1, 1.0);\n"
                             "			}\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	coreColor.rgb = coreColor.rgb + vec3(0.1, -0.1, 0.0) * nozzle;\n"
                             "\n"
                             "	if(!frontFacing())\n"
                             "	{\n"
                             "		color = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "		color.a = 1.0;\n"
                             "		vec3 fbnormal = -fnormal;\n"
                             "		vec4 ambient_color_t 	  = ambient + vec4(0.03, 0.03, 0.03, 0.0);\n"
                             "		vec4 diffuse_color_t    = diffuse;\n"
                             "		vec4 specular_color_t   = specular;\n"
                             "		coreColor = directLight(lightDir, fbnormal, color, ambient_color_t, diffuse_color_t, specular_color_t);\n"
                             "	}\n"
                             "\n"
                             "    //int fz = fanzhuan % 2;\n"
                             "    //   \n"
                             "    //if(fz == 0)\n"
                             "    //{\n"
                             "    //    if(! frontFacing())\n"
                             "    //    {\n"
                             "    //        //coreColor = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "	//		coreColor.a = 1.0;\n"
                             "    //    }\n"
                             "    //}\n"
                             "    //else\n"
                             "    //{\n"
                             "    //    if(frontFacing())\n"
                             "    //    {\n"
                             "    //        //coreColor = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "	//		coreColor.a = 1.0;\n"
                             "    //    }\n"
                             "    //}\n"
                             "\n"
                             "	if (renderModel != 1) {\n"
                             "		vec3 baryDelta = fwidth(barycentric);\n"
                             "			\n"
                             "		vec3 edgeFactor = smoothstep(vec3(0.0), baryDelta * 1.0, barycentric);\n"
                             "		float minEdgeFactor = min(min(edgeFactor.x, edgeFactor.y), edgeFactor.z);\n"
                             "\n"
                             "		if (renderModel == 2) {\n"
                             "			\n"
                             "			if (minEdgeFactor >= 1.0) {\n"
                             "                discard;\n"
                             "            }\n"
                             "            coreColor.rgb = mix(wireframeColor, clearColor, minEdgeFactor);\n"
                             "\n"
                             "		} else if (renderModel == 3) {\n"
                             "			coreColor.rgb = mix(wireframeColor, coreColor.rgb, minEdgeFactor);\n"
                             "		}\n"
                             "	}\n"
                             "\n"
                             "	gl_FragColor = vec4(coreColor.rgb, transparency);\n"
                             "}\n"
;
const char* gles_modelwireframe_geom = 
                             "/* modelwireframe.geom */\n"
                             "\n"
                             "layout (triangles) in;\n"
                             "layout (triangle_strip, max_vertices = 3) out;\n"
                             "\n"
                             "in vec3 viewDirectionVS[3];\n"
                             "in vec3 normalVS[3];\n"
                             "in vec3 gnormalVS[3];\n"
                             "in vec3 worldPositionVS[3];\n"
                             "in vec3 worldWaterVS[3];\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 gnormal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying vec3 worldWater;\n"
                             "varying vec3 barycentric;\n"
                             "\n"
                             "\n"
                             "void combindVertex(int index)\n"
                             "{\n"
                             "    gl_Position = gl_in[index].gl_Position;\n"
                             "\n"
                             "    viewDirection = viewDirectionVS[index];\n"
                             "    normal = normalVS[index];\n"
                             "    gnormal = gnormalVS[index];\n"
                             "    worldPosition = worldPositionVS[index];\n"
                             "    worldWater = worldWaterVS[index];\n"
                             "\n"
                             "    EmitVertex();\n"
                             "}\n"
                             "\n"
                             "\n"
                             "void main() {\n"
                             "    \n"
                             "    barycentric = vec3(1.0, 0.0, 0.0);\n"
                             "    combindVertex(0);\n"
                             "    \n"
                             "    barycentric = vec3(0.0, 1.0, 0.0);\n"
                             "    combindVertex(1);\n"
                             "\n"
                             "    barycentric = vec3(0.0, 0.0, 1.0);\n"
                             "    combindVertex(2);\n"
                             "\n"
                             "    EndPrimitive();\n"
                             "}\n"
;
const char* gles_modelwireframe_vert = 
                             "/* modelwireframe.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform vec3 water;\n"
                             "\n"
                             "varying vec3 viewDirectionVS;\n"
                             "varying vec3 normalVS;\n"
                             "varying vec3 gnormalVS;\n"
                             "varying vec3 worldPositionVS;\n"
                             "varying vec3 worldWaterVS;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirectionVS  = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normalVS          = normalMatrix * vertexNormal;\n"
                             "    gnormalVS        = mat3(modelMatrix) * vertexNormal;\n"
                             "		\n"
                             "    worldPositionVS   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "    worldWaterVS = water;\n"
                             "}\n"
;
const char* gles_moon_fragment = 
                             "/* moon.fragment */\n"
                             "\n"
                             "varying float radius;\n"
                             "\n"
                             "uniform float D = 50.0;\n"
                             "uniform vec2 hs;\n"
                             "\n"
                             "vec3 hsv2rgb(vec3 c)\n"
                             "{\n"
                             "    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n"
                             "    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n"
                             "    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n"
                             "}\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	float thick = clamp(radius - D, 0.0, 1.0);\n"
                             "	\n"
                             "	float bright= thick;\n"
                             "	vec3 v = vec3(hs, bright);\n"
                             "	\n"
                             "	gl_FragColor = vec4(hsv2rgb(v), 1.0);\n"
                             "}\n"
;
const char* gles_moon_vert = 
                             "/* moon.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying float radius;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 worldPosition = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  worldPosition;\n"
                             "	\n"
                             "	radius = length(vertexPosition);\n"
                             "}\n"
;
const char* gles_overlay_fragment = 
                             "/* overlay.fragment */\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	gl_FragColor = color;\n"
                             "}\n"
;
const char* gles_overlay_vert = 
                             "/* overlay.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   vec4 pos = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "   pos.z = -pos.w;\n"
                             "   gl_Position = pos;\n"
                             "}\n"
;
const char* gles_photo_fragment = 
                             "/* photo.fragment */\n"
                             "\n"
                             "varying float height;\n"
                             "\n"
                             "uniform float D = 0.35;\n"
                             "uniform float maxHeight = 2.2;\n"
                             "uniform vec2 hs;\n"
                             "\n"
                             "vec3 hsv2rgb(vec3 c)\n"
                             "{\n"
                             "    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n"
                             "    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n"
                             "    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n"
                             "}\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	float thick = clamp(height - D, 0.0, maxHeight) / maxHeight;\n"
                             "	vec3 v = vec3(hs, thick);\n"
                             "	\n"
                             "	gl_FragColor = vec4(hsv2rgb(v), 1.0);\n"
                             "}\n"
;
const char* gles_photo_vert = 
                             "/* photo.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying float height;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 worldPosition = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  worldPosition;\n"
                             "	\n"
                             "	height = vertexPosition.z;\n"
                             "}\n"
;
const char* gles_pickFace_fragment = 
                             "/* PickFace Fragment*/\n"
                             "precision mediump float; \n"
                             "\n"
                             "varying vec4 passColor;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	gl_FragColor = passColor;\n"
                             "}\n"
;
const char* gles_pickFace_vert = 
                             "/* PickFace Vertex*/\n"
                             "\n"
                             "attribute vec4 vertexPosition;\n"
                             "\n"
                             "varying vec4 passColor;\n"
                             "\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform ivec2 vertexBase;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	int ids[2];\n"
                             "	ids[0] = int(vertexPosition.w / 3.0) + int(vertexBase.x / 3);\n"
                             "	ids[1] = int(vertexBase.x / 3);\n"
                             "	\n"
                             "	int _faceId = ids[vertexBase.y];\n"
                             "	int i3 = _faceId / 0x1000000;\n"
                             "	_faceId = _faceId - i3 * 0x1000000;\n"
                             "	int i2 = _faceId / 0x10000;\n"
                             "	_faceId = _faceId - i2 * 0x10000;\n"
                             "	int i1 = _faceId / 0x100;\n"
                             "	_faceId = _faceId - i1 * 0x100;\n"
                             "	int i0 = _faceId;\n"
                             "	\n"
                             "	vec4 position = vec4(vertexPosition.xyz, 1.0);\n"
                             "	passColor = vec4(\n"
                             "					float(i0) / 255.0,\n"
                             "					float(i1) / 255.0,\n"
                             "					float(i2) / 255.0,\n"
                             "					float(i3) / 255.0);\n"
                             "	\n"
                             "	gl_Position = projectionMatrix * viewMatrix * modelMatrix * position;\n"
                             "}\n"
;
const char* gles_pickFaceChunk_fragment = 
                             "/* pickFaceChunk.fragment */\n"
                             "\n"
                             "varying vec4 passColor;\n"
                             "varying float flag;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	if(flag == 0.0)\n"
                             "		discard;\n"
                             "	gl_FragColor = passColor;\n"
                             "}\n"
;
const char* gles_pickFaceChunk_vert = 
                             "/* pickFaceChunk.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute float vertexFlag;\n"
                             "\n"
                             "varying vec4 passColor;\n"
                             "varying float flag;\n"
                             "\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform ivec2 vertexBase;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	int ids[2];\n"
                             "	ids[0] = int(gl_VertexID / 3.0) + int(vertexBase.x / 3);\n"
                             "	ids[1] = int(vertexBase.x / 3);\n"
                             "	\n"
                             "	int _faceId = ids[vertexBase.y];\n"
                             "	int i3 = _faceId / 0x1000000;\n"
                             "	_faceId = _faceId - i3 * 0x1000000;\n"
                             "	int i2 = _faceId / 0x10000;\n"
                             "	_faceId = _faceId - i2 * 0x10000;\n"
                             "	int i1 = _faceId / 0x100;\n"
                             "	_faceId = _faceId - i1 * 0x100;\n"
                             "	int i0 = _faceId;\n"
                             "	\n"
                             "	vec4 position = vec4(vertexPosition, 1.0);\n"
                             "	passColor = vec4(\n"
                             "					float(i0) / 255.0,\n"
                             "					float(i1) / 255.0,\n"
                             "					float(i2) / 255.0,\n"
                             "					float(i3) / 255.0);\n"
                             "					\n"
                             "	//vec4 passColors[2];\n"
                             "	//passColors[0] = vec4(1.0, 0.0, 0.0, 1.0);\n"
                             "	//passColors[1] = vec4(0.0, 1.0, 0.0, 1.0);\n"
                             "	//\n"
                             "	//int index = vertexBase.x == 120000000 ? 1 : 0;\n"
                             "	//passColor = passColors[index];\n"
                             "	\n"
                             "	gl_Position = projectionMatrix * viewMatrix * modelMatrix * position;\n"
                             "	flag			= vertexFlag;\n"
                             "}\n"
;
const char* gles_pickFaceFlag_fragment = 
                             "/* PickFaceFlag Fragment*/\n"
                             "precision mediump float; \n"
                             "\n"
                             "varying vec4 passColor;\n"
                             "varying float flag;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	if(flag == 0.0)\n"
                             "		discard;\n"
                             "	gl_FragColor = passColor;\n"
                             "}\n"
;
const char* gles_pickFaceFlag_vert = 
                             "/* PickFaceFlag Vertex*/\n"
                             "\n"
                             "attribute vec4 vertexPosition;\n"
                             "attribute float vertexFlag;\n"
                             "\n"
                             "varying vec4 passColor;\n"
                             "varying float flag;\n"
                             "\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform ivec2 vertexBase;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	int ids[2];\n"
                             "	ids[0] = int(vertexPosition.w / 3.0) + int(vertexBase.x / 3);\n"
                             "	ids[1] = int(vertexBase.x / 3);\n"
                             "	\n"
                             "	int _faceId = ids[vertexBase.y];\n"
                             "	int i3 = _faceId / 0x1000000;\n"
                             "	_faceId = _faceId - i3 * 0x1000000;\n"
                             "	int i2 = _faceId / 0x10000;\n"
                             "	_faceId = _faceId - i2 * 0x10000;\n"
                             "	int i1 = _faceId / 0x100;\n"
                             "	_faceId = _faceId - i1 * 0x100;\n"
                             "	int i0 = _faceId;\n"
                             "	\n"
                             "	vec4 position = vec4(vertexPosition.xyz, 1.0);\n"
                             "	passColor = vec4(\n"
                             "					float(i0) / 255.0,\n"
                             "					float(i1) / 255.0,\n"
                             "					float(i2) / 255.0,\n"
                             "					float(i3) / 255.0);\n"
                             "	\n"
                             "	gl_Position = projectionMatrix * viewMatrix * modelMatrix * position;\n"
                             "	flag			= vertexFlag;\n"
                             "}\n"
;
const char* gles_printerbottom_fragment = 
                             "/* printerbottom.fragment */\n"
                             "\n"
                             "varying vec2 texcoord;\n"
                             "varying vec3 normal;\n"
                             "\n"
                             "uniform vec2 imageshape;\n"
                             "uniform vec2 imagebili;\n"
                             "uniform vec2 platformsize;\n"
                             "\n"
                             "uniform sampler2D shapeTexture;\n"
                             "uniform vec4 color;\n"
                             "uniform vec4 logcolor;\n"
                             "uniform int visible;\n"
                             "uniform int colorVisible;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	vec4 coloruse = color;\n"
                             "	vec4 finalcolor = color;\n"
                             "	gl_FragColor = color;\n"
                             "\n"
                             "	if(visible == 1)\n"
                             "	{\n"
                             "		vec2 per = platformsize / imageshape;\n"
                             "		float minv = per.x < per.y ? per.x : per.y;\n"
                             "		per = per / minv;\n"
                             "	\n"
                             "		vec2 bili = per * imagebili;\n"
                             "		//vec2 bili = vec2(1.0, 1.0) * imagebili;\n"
                             "		\n"
                             "		vec2 texuse = (texcoord - vec2(0.5, 0.5)) * bili + vec2(0.5, 0.5);\n"
                             "			\n"
                             "		if(texuse.x >= 0.0 && texuse.x <= 1.0 && texuse.y >= 0.0 && texuse.y <= 1.0)\n"
                             "		{\n"
                             "			coloruse = texture2D(shapeTexture, texuse);\n"
                             "			if(coloruse.a > 0.0 && colorVisible <= 0)\n"
                             "			{\n"
                             "				coloruse = logcolor;\n"
                             "			}\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	if(coloruse.a > 0.0)\n"
                             "		finalcolor = coloruse;\n"
                             "		\n"
                             "	vec3 fgnormal 		  =	normalize(normal);\n"
                             "	if(dot(fgnormal, vec3(0.0, 0.0, -1.0)) > 0)\n"
                             "	{\n"
                             "		finalcolor.a = 0.0;\n"
                             "	}\n"
                             "	gl_FragColor = finalcolor;\n"
                             "	\n"
                             "}\n"
;
const char* gles_printerbottom_vert = 
                             "/* printerbottom.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "attribute vec2 vertexTexcoord;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec2 texcoord;\n"
                             "varying vec3 normal;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "   texcoord = vertexTexcoord;\n"
                             "   \n"
                             "   mat3 normalMatrix = mat3(viewMatrix);\n"
                             "   normal          = normalMatrix * vertexNormal;\n"
                             "}\n"
;
const char* gles_printergrid_fragment = 
                             "/* printergrid.fragment */\n"
                             "precision mediump float;\n"
                             "varying vec2 flag;\n"
                             "uniform float visible;\n"
                             "uniform vec4 xshowcolor;\n"
                             "uniform vec4 yshowcolor;\n"
                             "uniform vec4 linecolor;\n"
                             "uniform vec4 xyIndexcolor;\n"
                             "uniform float highlight_index_x;\n"
                             "uniform float highlight_index_y;\n"
                             "void main() \n"
                             "{\n"
                             "	if(int(flag.x) == 0)\n"
                             "	{\n"
                             "		gl_FragColor = yshowcolor;\n"
                             "	}\n"
                             "	else if(int(flag.y) == 0)\n"
                             "	{\n"
                             "		gl_FragColor = xshowcolor;\n"
                             "	}\n"
                             "	else\n"
                             "	{\n"
                             "		//if((((int(flag.x/10.0))%4 > 0) || ((int(flag.y/10.0))%4 > 0)) && (visible == 0.0))\n"
                             "		//	discard;\n"
                             "		if(int(highlight_index_x) == int(flag.x) || int(highlight_index_y) == int(flag.y))\n"
                             "		{\n"
                             "			gl_FragColor = xyIndexcolor; // vec4(1.0, 1.0, 0.0,1.0);\n"
                             "		}\n"
                             "		else\n"
                             "		{\n"
                             "			gl_FragColor = linecolor;\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "\n"
                             "/*\n"
                             "	if (visible == 0.0)\n"
                             "	{\n"
                             "		discard;\n"
                             "	}\n"
                             "	else\n"
                             "	{\n"
                             "		if(((int(flag.x/10.0))%4 > 0) || ((int(flag.y/10.0))%4 > 0))\n"
                             "			//fragColor = showcolor;\n"
                             "			discard;\n"
                             "		else	\n"
                             "			fragColor = linecolor;\n"
                             "	}\n"
                             "	*/\n"
                             "}\n"
;
const char* gles_printergrid_vert = 
                             "/* printergrid.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec2 vertexFlag;\n"
                             "uniform mat4 modelViewProjection;\n"
                             "\n"
                             "varying vec2 flag;\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "   flag = vertexFlag;\n"
                             "}\n"
;
const char* gles_pure_fragment = 
                             "/* pure.fragment */\n"
                             "precision mediump float;\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	gl_FragColor = color;\n"
                             "}\n"
;
const char* gles_pure_vert = 
                             "/* pure.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "}\n"
;
const char* gles_slicepreview_fragment = 
                             "/* slicepreview.fragment */\n"
                             "\n"
                             "varying vec3 normal;\n"
                             "varying vec2 flag;\n"
                             "varying vec4 drawFlag;\n"
                             "varying vec4 smoothFlag;\n"
                             "varying vec3 viewDirection;\n"
                             "\n"
                             "uniform vec4 color = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "\n"
                             "uniform vec4 front_ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 front_diffuse = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 specular = vec4(0.2, 0.2, 0.2, 1.0);\n"
                             "\n"
                             "uniform vec3 light_direction1 = vec3(1.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform int showType = 0;\n"
                             "uniform int animation = 0;\n"
                             "\n"
                             "uniform vec4 clipValue;\n"
                             "uniform vec2 layershow;\n"
                             "uniform int layerstartflag_show;\n"
                             "\n"
                             "uniform vec4 typecolors[18];\n"
                             "uniform vec4 speedcolors[13];\n"
                             "uniform vec4 nozzlecolors[6];\n"
                             "\n"
                             "uniform int typecolorsshow[18];\n"
                             "\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 diffuse_color, vec4 core_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	diffuse_color         = diffuse_color * core_color;\n"
                             "	vec4 total_diffuse    = NdotL * diffuse_color;\n"
                             "	\n"
                             "//	/*\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower) * core_color;\n"
                             "//	*/\n"
                             "	\n"
                             "	return total_diffuse + specularColor;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(flag.x < clipValue.x || flag.x > clipValue.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x == clipValue.y && (flag.y < clipValue.z || flag.y > clipValue.w))\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x < layershow.x || flag.x > layershow.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(typecolorsshow[int(drawFlag.y)] == 0)\n"
                             "		discard;\n"
                             "	\n"
                             "	vec4 core_color = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "	vec3 lightDir = normalize(light_direction1);\n"
                             "	\n"
                             "	if(showType == 0)\n"
                             "	{\n"
                             "		int stype = int(drawFlag.x);\n"
                             "		core_color = speedcolors[stype];\n"
                             "	}\n"
                             "	else if(showType == 1)\n"
                             "		core_color = typecolors[int(drawFlag.y)];\n"
                             "	else if(showType == 2)\n"
                             "		core_color = nozzlecolors[int(drawFlag.z)];\n"
                             "		\n"
                             "	if(layerstartflag_show == 1 && smoothFlag.x > 0.0 && smoothFlag.x <= 0.2)\n"
                             "		core_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = front_ambient;\n"
                             "	vec4 diffuse_color    = front_diffuse;\n"
                             "	\n"
                             "	ambient_color 		  = ambient_color * core_color;\n"
                             "	\n"
                             "	vec4 light_color1     = directLight(lightDir, fnormal, diffuse_color, core_color);\n"
                             "	\n"
                             "	core_color = ambient_color + light_color1;\n"
                             "	core_color.a = color.a;\n"
                             "	\n"
                             "	if(animation > 0)\n"
                             "	{\n"
                             "		if(flag.x == clipValue.y)\n"
                             "		{\n"
                             "			core_color += vec4(0.3, 0.3, 0.3, 0.0);\n"
                             "		}\n"
                             "		else\n"
                             "		{\n"
                             "			core_color -= vec4(0.3, 0.3, 0.3, 0.0);\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	gl_FragColor = core_color;\n"
                             "}\n"
;
const char* gles_slicepreview_vert = 
                             "/* slicepreview.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "attribute vec2 vertexFlag;\n"
                             "attribute vec4 vertexDrawFlag;\n"
                             "attribute vec4 vertexSmoothFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 normal;\n"
                             "varying vec2 flag;\n"
                             "varying vec4 drawFlag;\n"
                             "varying vec4 smoothFlag;\n"
                             "varying vec3 viewDirection;\n"
                             "\n"
                             "void main( void )\n"
                             "{	\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 world_position = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  world_position;\n"
                             "	flag = vertexFlag;\n"
                             "	drawFlag = vertexDrawFlag;\n"
                             "	smoothFlag = vertexSmoothFlag;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-world_position));\n"
                             "    normal          = mat3(modelview_matrix) * vertexNormal;\n"
                             "}\n"
;
const char* gles_slicepreviewAD_fragment = 
                             "/* slicepreviewAD.fragment */\n"
                             "\n"
                             "varying vec3 normal;\n"
                             "varying vec2 flag;\n"
                             "varying vec4 drawFlag;\n"
                             "varying vec3 viewDirection;\n"
                             "\n"
                             "uniform vec4 color = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "\n"
                             "uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
                             "uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "\n"
                             "uniform vec3 light_direction1 = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform int showType = 0;\n"
                             "uniform int animation = 0;\n"
                             "uniform int retractionShow = 0;\n"
                             "\n"
                             "uniform vec4 clipValue;\n"
                             "uniform vec2 layershow;\n"
                             "\n"
                             "uniform vec4 typecolors[16];\n"
                             "uniform vec4 speedcolors[13];\n"
                             "uniform vec4 nozzlecolors[9];\n"
                             "\n"
                             "uniform int typecolorsshow[15];\n"
                             "\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 diffuse_color, vec4 core_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	diffuse_color         = diffuse_color * core_color;\n"
                             "	vec4 total_diffuse    = NdotL * diffuse_color;\n"
                             "	\n"
                             "//	/*\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "//	*/\n"
                             "	\n"
                             "	return total_diffuse + specularColor;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(flag.x < clipValue.x || flag.x > clipValue.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x == clipValue.y && (flag.y < clipValue.z || flag.y > clipValue.w))\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x < layershow.x || flag.x > layershow.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(typecolorsshow[int(drawFlag.y)] == 0)\n"
                             "		discard;\n"
                             "	\n"
                             "	vec4 core_color = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "	\n"
                             "	if(showType == 0)\n"
                             "	{\n"
                             "		core_color = typecolors[int(drawFlag.y)];\n"
                             "		if(retractionShow == 1)\n"
                             "		{\n"
                             "			if(int(drawFlag.y) == 13 || int(drawFlag.y) == 14)//travel and react\n"
                             "				core_color = typecolors[15];	\n"
                             "		}\n"
                             "	}\n"
                             "	else if(showType == 1)\n"
                             "	{\n"
                             "		core_color = nozzlecolors[int(drawFlag.z)];\n"
                             "		if(retractionShow == 1)\n"
                             "		{\n"
                             "			if(int(drawFlag.z) == 6 || int(drawFlag.z) == 7)//travel and react\n"
                             "				core_color = nozzlecolors[8];	\n"
                             "		}\n"
                             "	}\n"
                             "	else if(showType == 2)\n"
                             "	{\n"
                             "		int stype = int(drawFlag.x);\n"
                             "		core_color = speedcolors[stype];\n"
                             "	}\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = front_ambient;\n"
                             "	vec4 diffuse_color    = front_diffuse;\n"
                             "	\n"
                             "	ambient_color 		  = ambient_color * core_color;\n"
                             "	\n"
                             "	vec4 light_color1     = directLight(light_direction1, fnormal, diffuse_color, core_color);\n"
                             "	\n"
                             "	core_color = ambient_color + light_color1;\n"
                             "	core_color.a = color.a;\n"
                             "	\n"
                             "	if(animation > 0)\n"
                             "	{\n"
                             "		if(flag.x == clipValue.y)\n"
                             "		{\n"
                             "			core_color += vec4(0.3, 0.3, 0.3, 0.0);\n"
                             "		}\n"
                             "		else\n"
                             "		{\n"
                             "			core_color -= vec4(0.3, 0.3, 0.3, 0.0);\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	gl_FragColor = core_color;\n"
                             "}\n"
;
const char* gles_slicepreviewAD_vert = 
                             "/* slicepreviewAD.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "attribute vec2 vertexFlag;\n"
                             "attribute vec4 vertexDrawFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 normal;\n"
                             "varying vec2 flag;\n"
                             "varying vec4 drawFlag;\n"
                             "varying vec3 viewDirection;\n"
                             "\n"
                             "void main( void )\n"
                             "{	\n"
                             "	flag = vertexFlag;\n"
                             "	drawFlag = vertexDrawFlag;\n"
                             "\n"
                             "	mat4 usematrix = modelMatrix;\n"
                             "\n"
                             "	if((int(drawFlag.z) == 1 ||int(drawFlag.z) == 7) && int(drawFlag.w) == 1)\n"
                             "	{\n"
                             "		mat4 translate = mat4(\n"
                             "			1.0, 0.0, 0.0, 0.0,\n"
                             "			0.0, 1.0, 0.0, 0.0,\n"
                             "			0.0, 0.0, 1.0, 0.0,\n"
                             "			-35.0, 0.0, 0.0, 1.0\n"
                             "		);\n"
                             "		usematrix = modelMatrix * translate;\n"
                             "	}\n"
                             "	mat4 modelview_matrix = viewMatrix * usematrix;\n"
                             "	vec4 world_position = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  world_position;\n"
                             "	\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-world_position));\n"
                             "    normal          = mat3(modelview_matrix) * vertexNormal;\n"
                             "}\n"
;
const char* gles_slicepreviewpath_fragment = 
                             "/* slicepreviewpath.fragment */\n"
                             "\n"
                             "varying vec2 flag;\n"
                             "uniform vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 clipValue;\n"
                             "uniform vec2 layershow;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(flag.x < clipValue.x || flag.x > clipValue.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x == clipValue.y && (flag.y < clipValue.z || flag.y > clipValue.w))\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x < layershow.x || flag.x > layershow.y)\n"
                             "		discard;\n"
                             "	\n"
                             "	vec4 core_color = color;\n"
                             "	gl_FragColor = core_color;\n"
                             "}\n"
;
const char* gles_slicepreviewpath_vert = 
                             "/* slicepreviewpath.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec2 vertexFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec2 flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{	\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 world_position = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  world_position;\n"
                             "	flag = vertexFlag;\n"
                             "}\n"
;
const char* gles_splitplane_fragment = 
                             "/* splitplane.fragment */\n"
                             "\n"
                             "varying vec3 worldPosition;\n"
                             "uniform vec4 color;\n"
                             "uniform vec3 clip[2];\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	if(worldPosition.z < clip[0].z || worldPosition.z > clip[1].z\n"
                             "		|| worldPosition.x < clip[0].x || worldPosition.x > clip[1].x\n"
                             "		|| worldPosition.y < clip[0].y || worldPosition.y > clip[1].y)\n"
                             "		discard;\n"
                             "		\n"
                             "	gl_FragColor = color;\n"
                             "}\n"
;
const char* gles_splitplane_vert = 
                             "/* splitplane.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* gles_support_fragment = 
                             "/* Support Fragment*/\n"
                             "\n"
                             "precision mediump float;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying float flag;\n"
                             "\n"
                             "uniform vec4 ambient ;//= vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "uniform vec4 diffuse ;//= vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 specular;// = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "const float specularPower = 12.0;\n"
                             "const vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 stateColors[6];\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "const float topVisibleHeight = 100000.0;\n"
                             "const float bottomVisibleHeight = -1000.0;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	int xxx = int(flag);\n"
                             "    vec4 color = stateColors[int(1.0)];\n"
                             "//    color.a = flag;\n"
                             "\n"
                             "	if(worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight)\n"
                             "		discard;\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	float NdotL 		  = dot(fnormal, lightDirection);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - lightDirection);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + specularColor + diffuseColor;\n"
                             "	\n"
                             "    if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "	{\n"
                             "		coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "	}\n"
                             "	\n"
                             "//        if( abs(worldPosition.z - bottom) < 0.01 )\n"
                             "//        {\n"
                             "//                coreColor.g += 0.4;\n"
                             "//        }\n"
                             "	\n"
                             "	//gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n"
                             "   gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_support_vert = 
                             "/* Support Vertex*/\n"
                             "precision mediump float;\n"
                             "attribute vec4 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "attribute float vertexFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying float flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition.xyz, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition.xyz, 1.0));\n"
                             "	flag			= vertexFlag;\n"
                             "	if(vertexFlag == 0.0)\n"
                             "	{\n"
                             "		gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "	}\n"
                             "}\n"
;
const char* gles_supportpos_fragment = 
                             "/* supportpos.fragment */\n"
                             "\n"
                             "noperspective varying vec3 viewDirection;\n"
                             "noperspective varying vec3 normal;\n"
                             "noperspective varying vec3 worldPosition;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.4, 0.4, 0.4, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.6, 0.6, 0.6, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 stateColors = vec4(0.8, 0.5, 0.8, 1.0);\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight)\n"
                             "		discard;\n"
                             "		\n"
                             "	vec4 color = stateColors;	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	float NdotL 		  = max(dot(fnormal, lightDirection), 0.0);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = reflect(-lightDirection, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "\n"
                             "	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_supportpos_vert = 
                             "/* supportpos.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "noperspective varying vec3 viewDirection;\n"
                             "noperspective varying vec3 normal;\n"
                             "noperspective varying vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* gles_supportshow_fragment = 
                             "/* supportshow.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying float flag;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "uniform vec4 diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 stateColors[6];\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    vec4 color = stateColors[int(flag)];\n"
                             "//    color.a = flag;\n"
                             "\n"
                             "	if(worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight)\n"
                             "		discard;\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	float NdotL 		  = dot(fnormal, lightDirection);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - lightDirection);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	\n"
                             "//        if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "//	{\n"
                             "//		coreColor.g += 0.4;\n"
                             "//	}\n"
                             "	\n"
                             "//        if( abs(worldPosition.z - bottom) < 0.01 )\n"
                             "//        {\n"
                             "//                coreColor.g += 0.4;\n"
                             "//        }\n"
                             "	\n"
                             "        gl_FragColor = vec4(coreColor.rgb, color.a);\n"
                             "}\n"
                             "\n"
;
const char* gles_supportshow_vert = 
                             "/* supportshow.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "attribute float vertexFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying float flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "	flag			= vertexFlag;\n"
                             "	\n"
                             "	if(vertexFlag == 0.0)\n"
                             "	{\n"
                             "		gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "	}\n"
                             "}\n"
;
const char* gles_tex_fragment = 
                             "/* tex.fragment */\n"
                             "\n"
                             "uniform sampler2D shapeTexture;\n"
                             "\n"
                             "varying vec2 texcoord;\n"
                             "void main() \n"
                             "{\n"
                             "	vec4 color = texture2D(shapeTexture, texcoord);\n"
                             "	if(color.w == 1.0) discard;\n"
                             "	gl_FragColor = vec4(color.xyz, 1.0);  \n"
                             "}\n"
;
const char* gles_tex_vert = 
                             "/* tex.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec2 vertexTexcoord;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "varying vec2 texcoord;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "   texcoord = vertexTexcoord;\n"
                             "}\n"
;
const char* gles_texshape_fragment = 
                             "/* texshape.fragment */\n"
                             "\n"
                             "uniform sampler2D shapeTexture;\n"
                             "\n"
                             "varying vec2 texcoord;\n"
                             "void main() \n"
                             "{\n"
                             "	vec4 color = texture2D(shapeTexture, texcoord);\n"
                             "	if(color.a == 0.0)\n"
                             "	{\n"
                             "		color = vec4(0.44, 0.44, 0.44, 1.0);\n"
                             "	}\n"
                             "	gl_FragColor = vec4(color.rgb, 1.0);  \n"
                             "}\n"
;
const char* gles_texshape_vert = 
                             "/* texshape.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec2 vertexTexcoord;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "varying vec2 texcoord;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "   texcoord = vertexTexcoord;\n"
                             "}\n"
;
const char* gles_text_fragment = 
                             "/* text.fragment */ \n"
                             "\n"
                             "uniform vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	gl_FragColor = color;\n"
                             "}\n"
;
const char* gles_text_vert = 
                             "/* text.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "}\n"
;
const char* gles_xyzIndicator_fragment = 
                             "/* xyzIndicator.fragment */\n"
                             "precision mediump float;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "const vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "const vec4 diffuse = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "const vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "const float specularPower = 12.0;\n"
                             "const vec3 lightDirection = vec3(1.0, 0.0, 0.0);\n"
                             "\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "		\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "	\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient, diffuse, specular);	\n"
                             "	\n"
                             "	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_xyzIndicator_vert = 
                             "/* xyzIndicator.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying vec3  worldWater;\n"
                             "\n"
                             "void main( void ) \n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition.xyz, 1.0);\n"
                             "	gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "	normal          = normalMatrix * vertexNormal;\n"
                             "	\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition.xyz, 1.0));\n"
                             "	\n"
                             "}\n"
;
const char* gles_zproject_fragment = 
                             "/* zproject.fragment */\n"
                             "\n"
                             "uniform int cameraDir;\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(cameraDir == 0)\n"
                             "		discard;\n"
                             "		\n"
                             "	gl_FragColor = vec4(0.1451, 0.1569, 0.1647, 1.0);\n"
                             "}\n"
;
const char* gles_zproject_vert = 
                             "/* zproject.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "//uniform float projectZ = 0.01;\n"
                             "uniform float projectZ;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    vec4 tworldPosition = modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "	tworldPosition.z = projectZ;\n"
                             "    gl_Position = projectionMatrix * viewMatrix *  tworldPosition;\n"
                             "}\n"
;
//-----------gles code array.
const char* gles_shader_code_array[77] = {
	gles_admodel_fragment,
	gles_admodel_vert,
	gles_bottomface_fragment,
	gles_bottomface_vert,
	gles_boxclippure_fragment,
	gles_boxclippure_vert,
	gles_chunk_fragment,
	gles_chunk_vert,
	gles_color_fragment,
	gles_color_vert,
	gles_dlpsupportindicator_fragment,
	gles_dlpsupportindicator_vert,
	gles_finephong_fragment,
	gles_finephong_vert,
	gles_finephongtex_fragment,
	gles_finephongtex_vert,
	gles_glcomp1_fragment,
	gles_glcomp1_vert,
	gles_manipulate_fragment,
	gles_manipulate_vert,
	gles_model_fragment,
	gles_model_vert,
	gles_modeldlp_fragment,
	gles_modeldlp_vert,
	gles_modelline_fragment,
	gles_modelline_vert,
	gles_modelselect_fragment,
	gles_modelselect_vert,
	gles_modelsimple_fragment,
	gles_modelsimple_vert,
	gles_modelSupport_fragment,
	gles_modelSupport_vert,
	gles_modelwireframe_fragment,
	gles_modelwireframe_geom,
	gles_modelwireframe_vert,
	gles_moon_fragment,
	gles_moon_vert,
	gles_overlay_fragment,
	gles_overlay_vert,
	gles_photo_fragment,
	gles_photo_vert,
	gles_pickFace_fragment,
	gles_pickFace_vert,
	gles_pickFaceChunk_fragment,
	gles_pickFaceChunk_vert,
	gles_pickFaceFlag_fragment,
	gles_pickFaceFlag_vert,
	gles_printerbottom_fragment,
	gles_printerbottom_vert,
	gles_printergrid_fragment,
	gles_printergrid_vert,
	gles_pure_fragment,
	gles_pure_vert,
	gles_slicepreview_fragment,
	gles_slicepreview_vert,
	gles_slicepreviewAD_fragment,
	gles_slicepreviewAD_vert,
	gles_slicepreviewpath_fragment,
	gles_slicepreviewpath_vert,
	gles_splitplane_fragment,
	gles_splitplane_vert,
	gles_support_fragment,
	gles_support_vert,
	gles_supportpos_fragment,
	gles_supportpos_vert,
	gles_supportshow_fragment,
	gles_supportshow_vert,
	gles_tex_fragment,
	gles_tex_vert,
	gles_texshape_fragment,
	gles_texshape_vert,
	gles_text_fragment,
	gles_text_vert,
	gles_xyzIndicator_fragment,
	gles_xyzIndicator_vert,
	gles_zproject_fragment,
	gles_zproject_vert
};
//------------ gl3.0 code
const char* admodel_fragment = 
                             "#version 150 core \n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "in vec3 worldPosition;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.4, 0.4, 0.4, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.6, 0.6, 0.6, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float error;\n"
                             "\n"
                             "uniform float sceneBottom;\n"
                             "uniform float sceneTop;\n"
                             "uniform sampler1D shapeTexture;\n"
                             "\n"
                             "uniform int fanzhuan = 0;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform vec4 stateColors[5];\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower);\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "vec4 changeColor(vec3 wordPos)\n"
                             "{\n"
                             "	float delta = sceneTop - sceneBottom;\n"
                             "	if(delta < 1.0)\n"
                             "		delta = 1.0;\n"
                             "	\n"
                             "	float texCoord = (wordPos.z - sceneBottom)/delta;\n"
                             "	return texture(shapeTexture, texCoord);\n"
                             "	//return vec4(texCoord, 0.0, 0.0, 1.0);\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec4 color = stateColors[int(state)];	\n"
                             "	if(error == 1.0)\n"
                             "		color = stateColors[3];\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = ambient;\n"
                             "	vec4 diffuse_color    = diffuse;\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec4 coreColor = directLight(lightDirection, fnormal, color, ambient_color, diffuse_color, specular_color);\n"
                             "	if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "	{\n"
                             "		coreColor.g += 0.4;\n"
                             "	}\n"
                             "	\n"
                             "	coreColor += changeColor(worldPosition);\n"
                             "	\n"
                             "	int fz = fanzhuan % 2;\n"
                             "	\n"
                             "	if(fz == 0)\n"
                             "	{\n"
                             "		if(!gl_FrontFacing)\n"
                             "		{\n"
                             "			coreColor.rgb = vec3(0.65, 0.75, 0.65) - coreColor.rgb;\n"
                             "		}\n"
                             "	}\n"
                             "	else\n"
                             "	{\n"
                             "		if(gl_FrontFacing)\n"
                             "		{\n"
                             "			coreColor.rgb = vec3(0.65, 0.75, 0.65) - coreColor.rgb;\n"
                             "		}\n"
                             "	}\n"
                             "   \n"
                             "	fragmentColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* admodel_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix  = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition   = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position           = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirection         = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix     = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normal          	  = normalMatrix * vertexNormal;\n"
                             "    worldPosition   	  = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* bottomface_fragment = 
                             "#version 150 core \n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "in vec3 normal;\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	vec4 finalcolor = color;\n"
                             "\n"
                             "	vec3 fgnormal 		  =	normalize(normal);\n"
                             "	if(dot(fgnormal, vec3(0.0, 0.0, -1.0)) > 0)\n"
                             "	{\n"
                             "		finalcolor.a = 0.0;\n"
                             "	}\n"
                             "	fragColor = finalcolor;\n"
                             "	\n"
                             "}\n"
;
const char* bottomface_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec2 texcoord;\n"
                             "out vec3 normal;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "   \n"
                             "   mat3 normalMatrix = mat3(viewMatrix);\n"
                             "   normal          = normalMatrix * vertexNormal;\n"
                             "}\n"
;
const char* boxclippure_fragment = 
                             "#version 150 core\n"
                             " \n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "in vec3 worldPosition;\n"
                             "uniform vec4 color;\n"
                             "uniform vec3 clip[2];\n"
                             "\n"
                             "uniform float intensity = 5.0;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	fragColor = color;\n"
                             "	#if 0\n"
                             "	if ( worldPosition.z < clip[0].z || worldPosition.z > clip[1].z\n"
                             "        || worldPosition.x < clip[0].x || worldPosition.x > clip[1].x\n"
                             "        || worldPosition.y < clip[0].y || worldPosition.y > clip[1].y) \n"
                             "	{\n"
                             "		discard;\n"
                             "	} else {\n"
                             "	\n"
                             "		float x = min( abs(worldPosition.x - clip[0].x), abs(worldPosition.x - clip[1].x) );\n"
                             "		float y = min( abs(worldPosition.y - clip[0].y), abs(worldPosition.y - clip[1].y) );\n"
                             "		float z = min( abs(worldPosition.z - clip[0].z), abs(worldPosition.z - clip[1].z) );\n"
                             "		\n"
                             "		x = min(x, y);\n"
                             "		x = min(x, z);\n"
                             "\n"
                             "		float k = clamp(x * intensity, 0.0, 1.0);\n"
                             "		fragColor = vec4(color.rgb, color.a * k);\n"
                             "	}\n"
                             "	#endif\n"
                             "}\n"
;
const char* boxclippure_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 worldPosition;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* chunk_fragment = 
                             "#version 150 core \n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "uniform vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n"
                             "flat in float flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(flag == 0.0)\n"
                             "		discard;	\n"
                             "\n"
                             "	fragmentColor = color;\n"
                             "}\n"
;
const char* chunk_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "in float vertexFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "flat out float flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	flag			= vertexFlag;\n"
                             "}\n"
;
const char* color_fragment = 
                             "#version 150 core \n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "in vec4 fcolor;\n"
                             "void main() \n"
                             "{\n"
                             "	fragColor = fcolor;\n"
                             "}\n"
;
const char* color_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec4 vertexColor;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "out vec4 fcolor;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "   fcolor = vertexColor;\n"
                             "}\n"
;
const char* dlpsupportindicator_fragment = 
                             "#version 150 core \n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "in vec3 worldPosition;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "uniform vec4 diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	float NdotL 		  = dot(fnormal, lightDirection);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - lightDirection);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;	\n"
                             "	\n"
                             "    fragmentColor = vec4(coreColor.rgb, color.a);\n"
                             "}\n"
                             "\n"
;
const char* dlpsupportindicator_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* finephong_fragment = 
                             "#version 150 core \n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "\n"
                             "uniform vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform float specularPower = 128.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec4 _color			  = color;\n"
                             "	if(!gl_FrontFacing)\n"
                             "    {\n"
                             "		_color = vec4(0.65, 0.0, 0.0, 1.0);\n"
                             "    }\n"
                             "	\n"
                             "	float NdotL 		  = max(dot(fnormal, lightDirection), 0.0);\n"
                             "	vec4 ambientColor 	  = ambient * _color;\n"
                             "	vec3 freflection      = reflect(-lightDirection, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * _color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	fragmentColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* finephong_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 worldPosition = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  worldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-worldPosition));\n"
                             "    normal          = mat3(modelview_matrix) * vertexNormal;\n"
                             "}\n"
;
const char* finephongtex_fragment = 
                             "#version 150 core \n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "\n"
                             "uniform sampler2D shapeTexture;\n"
                             "\n"
                             "in vec2 texcoord;\n"
                             "\n"
                             "uniform vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform float specularPower = 128.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform float useAzi = 0.0;\n"
                             "\n"
                             "vec2 azi_to_equ(vec2 tc)\n"
                             "{\n"
                             "	vec2 zaiTC = tc;\n"
                             "	if(useAzi == 1.0)\n"
                             "	{\n"
                             "		float PI = 3.1415926;\n"
                             "		vec2 t = vec2(tc.x - 0.5, tc.y - 0.5);\n"
                             "		float alpha = atan(t.y, t.x);\n"
                             "		float r = length(t);\n"
                             "		if(r > 0.5)\n"
                             "			zaiTC = vec2(-1.0, -1.0);\n"
                             "		else\n"
                             "		{\n"
                             "			float beta = 2 * PI * r;\n"
                             "			float x_ = 0.5 + 0.5 * alpha / PI;\n"
                             "			float y_= 1 - beta / PI;\n"
                             "			zaiTC = vec2(x_, y_);\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	return zaiTC;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec4 _color			  = color * texture(shapeTexture, azi_to_equ(texcoord));\n"
                             "	if(!gl_FrontFacing)\n"
                             "    {\n"
                             "		_color = vec4(0.65, 0.0, 0.0, 1.0);\n"
                             "    }\n"
                             "	\n"
                             "	float NdotL 		  = max(dot(fnormal, lightDirection), 0.0);\n"
                             "	vec4 ambientColor 	  = ambient * _color;\n"
                             "	vec3 freflection      = reflect(-lightDirection, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * _color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	fragmentColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* finephongtex_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "in vec2 vertexTexcoord;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec2 texcoord;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 worldPosition = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  worldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-worldPosition));\n"
                             "    normal          = mat3(modelview_matrix) * vertexNormal;\n"
                             "	texcoord = vertexTexcoord;\n"
                             "}\n"
;
const char* glcomp1_fragment = 
                             "#version 150 core \n"
                             "\n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "in vec3 gnormal;\n"
                             "in vec3 worldPosition;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection));\n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec3 fgnormal 		  =	normalize(gnormal);\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "\n"
                             "	if(!gl_FrontFacing)\n"
                             "	{\n"
                             "		color = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "		fnormal = - fnormal;\n"
                             "	}\n"
                             "	\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient, diffuse, specular);\n"
                             "	fragmentColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* glcomp1_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec3 gnormal;\n"
                             "out vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "    gnormal        = mat3(modelMatrix) * vertexNormal;\n"
                             "		\n"
                             "    worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* manipulate_fragment = 
                             "#version 150 core\n"
                             " \n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "uniform vec4 changecolor;\n"
                             "uniform int mt;\n"
                             "\n"
                             "uniform float state;\n"
                             "void main() \n"
                             "{\n"
                             "	if(mt == 0)\n"
                             "	{\n"
                             "		fragColor = color * state;\n"
                             "	}\n"
                             "	else if(mt == 1)\n"
                             "	{\n"
                             "		fragColor = color + changecolor * state;\n"
                             "	}\n"
                             "	\n"
                             "}\n"
;
const char* manipulate_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "}\n"
;
const char* model_fragment = 
                             "#version 150 core \n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "in vec3 gnormal;\n"
                             "in vec3 worldPosition;\n"
                             "in vec3 worldWater;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform int lightingEnable = 1;\n"
                             "uniform float transparency = 1.0;\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "uniform float error;\n"
                             "uniform float supportCos = 0.5;\n"
                             "\n"
                             "uniform int hoverState = 0;\n"
                             "uniform int waterState = 0;\n"
                             "uniform int fanzhuan = 0;\n"
                             "uniform int checkscope = 1;\n"
                             "\n"
                             "uniform float zcha = 0.01;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform float nozzle;\n"
                             "uniform vec4 stateColors[6];\n"
                             "uniform vec4 customColor;\n"
                             "\n"
                             "bool frontFacing()\n"
                             "{\n"
                             "        vec3 fdx = dFdx(worldPosition);\n"
                             "        vec3 fdy = dFdy(worldPosition);\n"
                             "        return dot(gnormal, cross(fdx, fdy)) > 0.0;\n"
                             "} \n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return lightingEnable * (ambient_color + diffuse_color + specular_color) + (1 - lightingEnable) * core_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(checkscope > 0 && (worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight))\n"
                             "		discard;\n"
                             "\n"
                             "	int stateInt = int(state);\n"
                             "	vec4 color;\n"
                             "	if (stateInt < 5)\n"
                             "		color = stateColors[stateInt];\n"
                             "	else\n"
                             "		color = customColor;\n"
                             "	\n"
                             "	if(error == 1.0)\n"
                             "		color = stateColors[3];	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = ambient;\n"
                             "	vec4 diffuse_color    = diffuse;\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient_color, diffuse_color, specular_color);\n"
                             "	\n"
                             "	vec3 fgnormal 		  =	normalize(gnormal);\n"
                             "	\n"
                             "	if(checkscope > 0)\n"
                             "	{\n"
                             "		if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "		if( abs(worldPosition.z - bottom) < 0.05 )\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	\n"
                             "	if(hoverState > 0)\n"
                             "	{\n"
                             "		float v = dot(fgnormal, vec3(0.0, 0.0, -1.0));\n"
                             "		if(v >= supportCos)\n"
                             "		{\n"
                             "			coreColor.r += 0.8 * v;\n"
                             "		}\n"
                             "		\n"
                             "		if(waterState == 1)\n"
                             "		{\n"
                             "			if(abs(worldPosition.z - worldWater.z) < zcha)\n"
                             "			{\n"
                             "				coreColor = vec4(0.1, 0.1, 0.1, 1.0);\n"
                             "			}\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	coreColor.rgb = coreColor.rgb + vec3(0.1, -0.1, 0.0) * nozzle;\n"
                             "\n"
                             "	if(!frontFacing())\n"
                             "	{\n"
                             "		color = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "		color.a = 1.0;\n"
                             "		vec3 fbnormal = -fnormal;\n"
                             "		vec4 ambient_color_t 	  = ambient + vec4(0.03, 0.03, 0.03, 0.0);\n"
                             "		vec4 diffuse_color_t    = diffuse;\n"
                             "		vec4 specular_color_t   = specular;\n"
                             "		coreColor = directLight(lightDir, fbnormal, color, ambient_color_t, diffuse_color_t, specular_color_t);\n"
                             "	}\n"
                             "\n"
                             "    //int fz = fanzhuan % 2;\n"
                             "    //   \n"
                             "    //if(fz == 0)\n"
                             "    //{\n"
                             "    //    if(! frontFacing())\n"
                             "    //    {\n"
                             "    //        //coreColor = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "	//		coreColor.a = 1.0;\n"
                             "    //    }\n"
                             "    //}\n"
                             "    //else\n"
                             "    //{\n"
                             "    //    if(frontFacing())\n"
                             "    //    {\n"
                             "    //        //coreColor = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "	//		coreColor.a = 1.0;\n"
                             "    //    }\n"
                             "    //}\n"
                             "\n"
                             "	fragmentColor = vec4(coreColor.rgb, transparency);\n"
                             "}\n"
;
const char* model_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform vec3 water;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec3 gnormal;\n"
                             "out vec3 worldPosition;\n"
                             "out vec3  worldWater;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "    gnormal        = mat3(modelMatrix) * vertexNormal;\n"
                             "		\n"
                             "    worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "    worldWater = water;\n"
                             "}\n"
;
const char* modeldlp_fragment = 
                             "#version 150 core\n"
                             "out vec4 fragmentColor;\n"
                             " \n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "in vec3 gnormal;\n"
                             "in vec3 worldPosition;\n"
                             "\n"
                             "uniform int state;\n"
                             "uniform float error;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 clipPlane1;\n"
                             "uniform vec4 clipPlane2;\n"
                             "\n"
                             "uniform int checkScope = 1;\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float supportCos = 0.5;\n"
                             "\n"
                             "uniform int hoverState = 0;\n"
                             "uniform int waterState = 0;\n"
                             "\n"
                             "const float zcha = 0.1;\n"
                             "\n"
                             "uniform vec4 stateColors[6];\n"
                             "uniform vec3 water;\n"
                             "bool frontFacing()\n"
                             "{\n"
                             "        vec3 fdx = dFdx(worldPosition);\n"
                             "        vec3 fdy = dFdy(worldPosition);\n"
                             "        return dot(gnormal, cross(fdx, fdy)) > 0.0;\n"
                             "}\n"
                             "float distance2Plane(vec3 position, vec4 plane)\n"
                             "{\n"
                             "	vec3 p = position - vec3(0.0, 0.0, plane.w);\n"
                             "	return dot(p, plane.xyz);\n"
                             "}\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(distance2Plane(worldPosition, clipPlane1) < 0.0)\n"
                             "		discard;\n"
                             "\n"
                             "	if(distance2Plane(worldPosition, clipPlane2) < 0.0)\n"
                             "		discard;\n"
                             "		\n"
                             "	vec4 color = stateColors[state];\n"
                             "	color = error * stateColors[3] + (1.0 - error) * color;	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec3 fgnormal 		  =	normalize(gnormal);\n"
                             "		\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "\n"
                             "	if(!frontFacing())\n"
                             "	{\n"
                             "		color = vec4(stateColors[5].xyz, 1.0);\n"
                             "		fnormal = - fnormal;\n"
                             "	}\n"
                             "	\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient, diffuse, specular);	\n"
                             "	if(checkScope > 0)\n"
                             "	{\n"
                             "		if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < 0.1 || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	\n"
                             "	if(hoverState > 0)\n"
                             "	{\n"
                             "		float v = dot(fgnormal, vec3(0.0, 0.0, -1.0));\n"
                             "		if(v >= supportCos)\n"
                             "		{\n"
                             "			coreColor.r += 0.8 * v;\n"
                             "		}\n"
                             "		\n"
                             "		if(waterState == 1)\n"
                             "		{\n"
                             "			if(abs(worldPosition.z - water.z) < zcha)\n"
                             "			{\n"
                             "				coreColor = vec4(0.1, 0.1, 0.1, 1.0);\n"
                             "			}\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	fragmentColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* modeldlp_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec3 gnormal;\n"
                             "out vec3 worldPosition;\n"
                             "out vec3  worldWater;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "    gnormal        = mat3(modelMatrix) * vertexNormal;\n"
                             "		\n"
                             "    worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* modelline_fragment = 
                             "#version 150 core\n"
                             "out vec4 fragmentColor; \n"
                             "\n"
                             "in vec3 worldPosition;\n"
                             "\n"
                             "uniform vec3 machineCube;\n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "uniform float error;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform vec4 stateColors[5];\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight)\n"
                             "		discard;\n"
                             "\n"
                             "	vec4 color = stateColors[int(state)];	\n"
                             "	//if(abs(worldPosition.x) > machineCube.x/2.0 || abs(worldPosition.y) > machineCube.y/2.0 ||  worldPosition.z > machineCube.z || worldPosition.z < 0.0)\n"
                             "    //   color = stateColors[3];\n"
                             "	if(error == 1.0)\n"
                             "		color = stateColors[3];\n"
                             "	\n"
                             "	fragmentColor = vec4(0.1, 0.1, 0.1, 1.0);\n"
                             "}\n"
;
const char* modelline_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* modelselect_fragment = 
                             "#version 150 core \n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "noperspective in vec3 viewDirection;\n"
                             "noperspective in vec3 normal;\n"
                             "noperspective in vec3 worldPosition;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.4, 0.4, 0.4, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.6, 0.6, 0.6, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "uniform float error;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform float nozzle;\n"
                             "uniform vec4 stateColors[4];\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower);\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight)\n"
                             "		discard;\n"
                             "\n"
                             "	vec4 color = stateColors[int(state)];	\n"
                             "	if(error == 1.0)\n"
                             "		color = stateColors[3];\n"
                             "		\n"
                             "	vec4 back_color = color;\n"
                             "//	back_color.rgb = vec3(1.0, 1.0, 1.0) - back_color.rgb;\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = ambient;\n"
                             "	vec4 diffuse_color    = diffuse;\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec4 coreColor = directLight(lightDirection, fnormal, color, ambient_color, diffuse_color, specular_color);\n"
                             "	vec4 coreColor_b = directLight(lightDirection, -fnormal, back_color, ambient_color - vec4(0.2, 0.2, 0.2, 0.0), diffuse_color, specular_color);\n"
                             "	\n"
                             "	coreColor.g += 0.4;\n"
                             "	coreColor.r += 0.4;\n"
                             "	\n"
                             "	coreColor_b.g += 0.2;\n"
                             "	coreColor_b.r += 0.2;\n"
                             "	\n"
                             "	coreColor.rgb = coreColor.rgb + vec3(0.1, -0.1, 0.0) * nozzle;\n"
                             "	coreColor_b.rgb = coreColor_b.rgb + vec3(0.1, -0.1, 0.0) * nozzle;\n"
                             "	\n"
                             "	if(gl_FrontFacing)\n"
                             "    {\n"
                             "        fragmentColor = vec4(coreColor.rgb, 1.0);\n"
                             "    }\n"
                             "    else\n"
                             "    {\n"
                             "        fragmentColor = vec4(coreColor_b.rgb, 0.4);\n"
                             "    }\n"
                             "	\n"
                             "//	fragmentColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* modelselect_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* modelsimple_fragment = 
                             "#version 150 core \n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "noperspective in vec3 viewDirection;\n"
                             "noperspective in vec3 normal;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.4, 0.4, 0.4, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.6, 0.6, 0.6, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 stateColors = vec4(0.8, 0.5, 0.8, 1.0);\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec4 color = stateColors;	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	float NdotL 		  = max(dot(fnormal, lightDirection), 0.0);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = reflect(-lightDirection, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	\n"
                             "	fragmentColor = vec4(coreColor.rgb, 0.8);\n"
                             "}\n"
;
const char* modelsimple_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "noperspective out vec3 viewDirection;\n"
                             "noperspective out vec3 normal;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "}\n"
;
const char* modelSupport_fragment = 
                             "#version 150 core \n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "in vec3 worldPosition;\n"
                             "flat in vec3 gnormal;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "uniform vec4 diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "uniform float supportCos = 0.707;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform vec4 stateColors[4];\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec4 color = stateColors[int(state)];	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec3 fgnormal		  = normalize(gnormal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	if(dot(fgnormal, vec3(0.0, 0.0, -1.0)) > supportCos)\n"
                             "		color = stateColors[3];\n"
                             "		\n"
                             "	float NdotL 		  = max(dot(fnormal, lightDirection), 0.0);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = reflect(-lightDirection, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	fragmentColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* modelSupport_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec3 worldPosition;\n"
                             "flat out vec3 gnormal;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "	\n"
                             "	gnormal			= mat3(modelMatrix) * vertexNormal;\n"
                             "}\n"
;
const char* modelwireframe_fragment = 
                             "#version 150 core \n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "in vec3 gnormal;\n"
                             "in vec3 worldPosition;\n"
                             "in vec3 worldWater;\n"
                             "in vec3 barycentric;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform int lightingEnable = 1;\n"
                             "uniform float transparency = 1.0;\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "uniform float error;\n"
                             "uniform float supportCos = 0.5;\n"
                             "\n"
                             "uniform int hoverState = 0;\n"
                             "uniform int waterState = 0;\n"
                             "uniform int fanzhuan = 0;\n"
                             "uniform int checkscope = 1;\n"
                             "\n"
                             "uniform float zcha = 0.01;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform float nozzle;\n"
                             "uniform vec4 stateColors[6];\n"
                             "uniform vec4 customColor;\n"
                             "\n"
                             "uniform vec3 wireframeColor = vec3(0.1);\n"
                             "uniform vec3 clearColor = vec3(0.27);\n"
                             "uniform int renderModel = 1;\n"
                             "\n"
                             "bool frontFacing()\n"
                             "{\n"
                             "        vec3 fdx = dFdx(worldPosition);\n"
                             "        vec3 fdy = dFdy(worldPosition);\n"
                             "        return dot(gnormal, cross(fdx, fdy)) > 0.0;\n"
                             "} \n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return lightingEnable * (ambient_color + diffuse_color + specular_color) + (1 - lightingEnable) * core_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(checkscope > 0 && (worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight))\n"
                             "		discard;\n"
                             "\n"
                             "	int stateInt = int(state);\n"
                             "	vec4 color;\n"
                             "	if (stateInt < 5)\n"
                             "		color = stateColors[stateInt];\n"
                             "	else\n"
                             "		color = customColor;\n"
                             "	\n"
                             "	if(error == 1.0)\n"
                             "		color = stateColors[3];	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = ambient;\n"
                             "	vec4 diffuse_color    = diffuse;\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient_color, diffuse_color, specular_color);\n"
                             "	\n"
                             "	vec3 fgnormal 		  =	normalize(gnormal);\n"
                             "	\n"
                             "	if(checkscope > 0)\n"
                             "	{\n"
                             "		if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "		if( abs(worldPosition.z - bottom) < 0.05 )\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	\n"
                             "	if(hoverState > 0)\n"
                             "	{\n"
                             "		float v = dot(fgnormal, vec3(0.0, 0.0, -1.0));\n"
                             "		if(v >= supportCos)\n"
                             "		{\n"
                             "			coreColor.r += 0.8 * v;\n"
                             "		}\n"
                             "		\n"
                             "		if(waterState == 1)\n"
                             "		{\n"
                             "			if(abs(worldPosition.z - worldWater.z) < zcha)\n"
                             "			{\n"
                             "				coreColor = vec4(0.1, 0.1, 0.1, 1.0);\n"
                             "			}\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	coreColor.rgb = coreColor.rgb + vec3(0.1, -0.1, 0.0) * nozzle;\n"
                             "\n"
                             "	if(!frontFacing())\n"
                             "	{\n"
                             "		color = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "		color.a = 1.0;\n"
                             "		vec3 fbnormal = -fnormal;\n"
                             "		vec4 ambient_color_t 	  = ambient + vec4(0.03, 0.03, 0.03, 0.0);\n"
                             "		vec4 diffuse_color_t    = diffuse;\n"
                             "		vec4 specular_color_t   = specular;\n"
                             "		coreColor = directLight(lightDir, fbnormal, color, ambient_color_t, diffuse_color_t, specular_color_t);\n"
                             "	}\n"
                             "\n"
                             "    //int fz = fanzhuan % 2;\n"
                             "    //   \n"
                             "    //if(fz == 0)\n"
                             "    //{\n"
                             "    //    if(! frontFacing())\n"
                             "    //    {\n"
                             "    //        //coreColor = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "	//		coreColor.a = 1.0;\n"
                             "    //    }\n"
                             "    //}\n"
                             "    //else\n"
                             "    //{\n"
                             "    //    if(frontFacing())\n"
                             "    //    {\n"
                             "    //        //coreColor = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "	//		coreColor.a = 1.0;\n"
                             "    //    }\n"
                             "    //}\n"
                             "\n"
                             "	if (renderModel != 1) {\n"
                             "		vec3 baryDelta = fwidth(barycentric);\n"
                             "			\n"
                             "		vec3 edgeFactor = smoothstep(vec3(0.0), baryDelta * 1.0, barycentric);\n"
                             "		float minEdgeFactor = min(min(edgeFactor.x, edgeFactor.y), edgeFactor.z);\n"
                             "\n"
                             "		if (renderModel == 2) {\n"
                             "			\n"
                             "			if (minEdgeFactor >= 1.0) {\n"
                             "                discard;\n"
                             "            }\n"
                             "            coreColor.rgb = mix(wireframeColor, clearColor, minEdgeFactor);\n"
                             "\n"
                             "		} else if (renderModel == 3) {\n"
                             "			coreColor.rgb = mix(wireframeColor, coreColor.rgb, minEdgeFactor);\n"
                             "		}\n"
                             "	}\n"
                             "\n"
                             "	fragmentColor = vec4(coreColor.rgb, transparency);\n"
                             "}\n"
;
const char* modelwireframe_geom = 
                             "#version 150 core\n"
                             "\n"
                             "layout (triangles) in;\n"
                             "layout (triangle_strip, max_vertices = 3) out;\n"
                             "\n"
                             "in vec3 viewDirectionVS[3];\n"
                             "in vec3 normalVS[3];\n"
                             "in vec3 gnormalVS[3];\n"
                             "in vec3 worldPositionVS[3];\n"
                             "in vec3 worldWaterVS[3];\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec3 gnormal;\n"
                             "out vec3 worldPosition;\n"
                             "out vec3 worldWater;\n"
                             "out vec3 barycentric;\n"
                             "\n"
                             "\n"
                             "void combindVertex(int index)\n"
                             "{\n"
                             "    gl_Position = gl_in[index].gl_Position;\n"
                             "\n"
                             "    viewDirection = viewDirectionVS[index];\n"
                             "    normal = normalVS[index];\n"
                             "    gnormal = gnormalVS[index];\n"
                             "    worldPosition = worldPositionVS[index];\n"
                             "    worldWater = worldWaterVS[index];\n"
                             "\n"
                             "    EmitVertex();\n"
                             "}\n"
                             "\n"
                             "\n"
                             "void main() {\n"
                             "    \n"
                             "    barycentric = vec3(1.0, 0.0, 0.0);\n"
                             "    combindVertex(0);\n"
                             "    \n"
                             "    barycentric = vec3(0.0, 1.0, 0.0);\n"
                             "    combindVertex(1);\n"
                             "\n"
                             "    barycentric = vec3(0.0, 0.0, 1.0);\n"
                             "    combindVertex(2);\n"
                             "\n"
                             "    EndPrimitive();\n"
                             "}\n"
;
const char* modelwireframe_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform vec3 water;\n"
                             "\n"
                             "out vec3 viewDirectionVS;\n"
                             "out vec3 normalVS;\n"
                             "out vec3 gnormalVS;\n"
                             "out vec3 worldPositionVS;\n"
                             "out vec3 worldWaterVS;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirectionVS  = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normalVS          = normalMatrix * vertexNormal;\n"
                             "    gnormalVS        = mat3(modelMatrix) * vertexNormal;\n"
                             "		\n"
                             "    worldPositionVS   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "    worldWaterVS = water;\n"
                             "}\n"
;
const char* moon_fragment = 
                             "#version 150 core \n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "in float radius;\n"
                             "\n"
                             "uniform float D = 50.0;\n"
                             "uniform vec2 hs;\n"
                             "\n"
                             "vec3 hsv2rgb(vec3 c)\n"
                             "{\n"
                             "    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n"
                             "    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n"
                             "    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n"
                             "}\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	float thick = clamp(radius - D, 0.0, 1.0);\n"
                             "	\n"
                             "	float bright= thick;\n"
                             "	vec3 v = vec3(hs, bright);\n"
                             "	\n"
                             "	fragColor = vec4(hsv2rgb(v), 1.0);\n"
                             "}\n"
;
const char* moon_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out float radius;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 worldPosition = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  worldPosition;\n"
                             "	\n"
                             "	radius = length(vertexPosition);\n"
                             "}\n"
;
const char* overlay_fragment = 
                             "#version 150 core\n"
                             " \n"
                             "out vec4 fragColor;\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	fragColor = color;\n"
                             "}\n"
;
const char* overlay_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   vec4 pos = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "   pos.z = -pos.w;\n"
                             "   gl_Position = pos;\n"
                             "}\n"
;
const char* photo_fragment = 
                             " #version 150 core\n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "in float height;\n"
                             "\n"
                             "uniform float D = 0.35;\n"
                             "uniform float maxHeight = 2.2;\n"
                             "uniform vec2 hs;\n"
                             "\n"
                             "vec3 hsv2rgb(vec3 c)\n"
                             "{\n"
                             "    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n"
                             "    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n"
                             "    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n"
                             "}\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	float thick = clamp(height - D, 0.0, maxHeight) / maxHeight;\n"
                             "	vec3 v = vec3(hs, thick);\n"
                             "	\n"
                             "	fragColor = vec4(hsv2rgb(v), 1.0);\n"
                             "}\n"
;
const char* photo_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out float height;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 worldPosition = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  worldPosition;\n"
                             "	\n"
                             "	height = vertexPosition.z;\n"
                             "}\n"
;
const char* pickFace_fragment = 
                             "#version 150 core \n"
                             "\n"
                             "flat in vec4 passColor;\n"
                             "in vec3 passVert;\n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	fragColor = passColor;\n"
                             "}\n"
;
const char* pickFace_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "flat out vec4 passColor;\n"
                             "out vec3 passVert;\n"
                             "\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform ivec2 vertexBase;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	int ids[2];\n"
                             "	ids[0] = int(gl_VertexID / 3.0) + int(vertexBase.x / 3);\n"
                             "	ids[1] = int(vertexBase.x / 3);\n"
                             "	\n"
                             "	int _faceId = ids[vertexBase.y];\n"
                             "	int i3 = _faceId / 0x1000000;\n"
                             "	_faceId = _faceId - i3 * 0x1000000;\n"
                             "	int i2 = _faceId / 0x10000;\n"
                             "	_faceId = _faceId - i2 * 0x10000;\n"
                             "	int i1 = _faceId / 0x100;\n"
                             "	_faceId = _faceId - i1 * 0x100;\n"
                             "	int i0 = _faceId;\n"
                             "	\n"
                             "	vec4 position = vec4(vertexPosition, 1.0);\n"
                             "	passColor = vec4(\n"
                             "					float(i0) / 255.0,\n"
                             "					float(i1) / 255.0,\n"
                             "					float(i2) / 255.0,\n"
                             "					float(i3) / 255.0);\n"
                             "	\n"
                             "	passVert = (modelMatrix * position).xyz;\n"
                             "	gl_Position = projectionMatrix * viewMatrix * modelMatrix * position;\n"
                             "}\n"
;
const char* pickFaceChunk_fragment = 
                             "#version 150 core \n"
                             "\n"
                             "flat in vec4 passColor;\n"
                             "in float flag;\n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	if(flag == 0.0)\n"
                             "		discard;\n"
                             "	fragColor = passColor;\n"
                             "}\n"
;
const char* pickFaceChunk_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in float vertexFlag;\n"
                             "\n"
                             "flat out vec4 passColor;\n"
                             "out float flag;\n"
                             "\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform ivec2 vertexBase;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	int ids[2];\n"
                             "	ids[0] = int(gl_VertexID / 3.0) + int(vertexBase.x / 3);\n"
                             "	ids[1] = int(vertexBase.x / 3);\n"
                             "	\n"
                             "	int _faceId = ids[vertexBase.y];\n"
                             "	int i3 = _faceId / 0x1000000;\n"
                             "	_faceId = _faceId - i3 * 0x1000000;\n"
                             "	int i2 = _faceId / 0x10000;\n"
                             "	_faceId = _faceId - i2 * 0x10000;\n"
                             "	int i1 = _faceId / 0x100;\n"
                             "	_faceId = _faceId - i1 * 0x100;\n"
                             "	int i0 = _faceId;\n"
                             "	\n"
                             "	vec4 position = vec4(vertexPosition, 1.0);\n"
                             "	passColor = vec4(\n"
                             "					float(i0) / 255.0,\n"
                             "					float(i1) / 255.0,\n"
                             "					float(i2) / 255.0,\n"
                             "					float(i3) / 255.0);\n"
                             "					\n"
                             "	//vec4 passColors[2];\n"
                             "	//passColors[0] = vec4(1.0, 0.0, 0.0, 1.0);\n"
                             "	//passColors[1] = vec4(0.0, 1.0, 0.0, 1.0);\n"
                             "	//\n"
                             "	//int index = vertexBase.x == 120000000 ? 1 : 0;\n"
                             "	//passColor = passColors[index];\n"
                             "	\n"
                             "	gl_Position = projectionMatrix * viewMatrix * modelMatrix * position;\n"
                             "	flag			= vertexFlag;\n"
                             "}\n"
;
const char* pickFaceFlag_fragment = 
                             "#version 150 core \n"
                             "\n"
                             "flat in vec4 passColor;\n"
                             "in vec3 passVert;\n"
                             "in float flag;\n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	if(flag == 0.0)\n"
                             "		discard;\n"
                             "	fragColor = passColor;\n"
                             "	//fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n"
                             "}\n"
;
const char* pickFaceFlag_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in float vertexFlag;\n"
                             "\n"
                             "flat out vec4 passColor;\n"
                             "out vec3 passVert;\n"
                             "out float flag;\n"
                             "\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform ivec2 vertexBase;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	int ids[2];\n"
                             "	ids[0] = int(gl_VertexID / 3.0) + int(vertexBase.x / 3);\n"
                             "	ids[1] = int(vertexBase.x / 3);\n"
                             "	\n"
                             "	int _faceId = ids[vertexBase.y];\n"
                             "	int i3 = _faceId / 0x1000000;\n"
                             "	_faceId = _faceId - i3 * 0x1000000;\n"
                             "	int i2 = _faceId / 0x10000;\n"
                             "	_faceId = _faceId - i2 * 0x10000;\n"
                             "	int i1 = _faceId / 0x100;\n"
                             "	_faceId = _faceId - i1 * 0x100;\n"
                             "	int i0 = _faceId;\n"
                             "	\n"
                             "	vec4 position = vec4(vertexPosition, 1.0);\n"
                             "	passColor = vec4(\n"
                             "					float(i0) / 255.0,\n"
                             "					float(i1) / 255.0,\n"
                             "					float(i2) / 255.0,\n"
                             "					float(i3) / 255.0);\n"
                             "	\n"
                             "	passVert = (modelMatrix * position).xyz;\n"
                             "	gl_Position = projectionMatrix * viewMatrix * modelMatrix * position;\n"
                             "	flag			= vertexFlag;\n"
                             "}\n"
;
const char* printerbottom_fragment = 
                             "#version 150 core \n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "in vec2 texcoord;\n"
                             "in vec3 normal;\n"
                             "\n"
                             "uniform vec2 imageshape;\n"
                             "uniform vec2 imagebili;\n"
                             "uniform vec2 platformsize;\n"
                             "\n"
                             "uniform sampler2D shapeTexture;\n"
                             "uniform vec4 color;\n"
                             "uniform vec4 logcolor;\n"
                             "uniform int visible;\n"
                             "uniform int colorVisible;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	vec4 coloruse = color;\n"
                             "	vec4 finalcolor = color;\n"
                             "	fragColor = color;\n"
                             "\n"
                             "	if(visible == 1)\n"
                             "	{\n"
                             "		vec2 per = platformsize / imageshape;\n"
                             "		float minv = per.x < per.y ? per.x : per.y;\n"
                             "		per = per / minv;\n"
                             "	\n"
                             "		vec2 bili = per * imagebili;\n"
                             "		//vec2 bili = vec2(1.0, 1.0) * imagebili;\n"
                             "		\n"
                             "		vec2 texuse = (texcoord - vec2(0.5, 0.5)) * bili + vec2(0.5, 0.5);\n"
                             "			\n"
                             "		if(texuse.x >= 0.0 && texuse.x <= 1.0 && texuse.y >= 0.0 && texuse.y <= 1.0)\n"
                             "		{\n"
                             "			coloruse = texture(shapeTexture, texuse);\n"
                             "			if(coloruse.a > 0.0 && colorVisible <= 0)\n"
                             "			{\n"
                             "				coloruse = logcolor;\n"
                             "			}\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	if(coloruse.a > 0.0)\n"
                             "		finalcolor = coloruse;\n"
                             "		\n"
                             "	vec3 fgnormal 		  =	normalize(normal);\n"
                             "	if(dot(fgnormal, vec3(0.0, 0.0, -1.0)) > 0)\n"
                             "	{\n"
                             "		finalcolor.a = 0.0;\n"
                             "	}\n"
                             "	fragColor = finalcolor;\n"
                             "	\n"
                             "}\n"
;
const char* printerbottom_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "in vec2 vertexTexcoord;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec2 texcoord;\n"
                             "out vec3 normal;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "   texcoord = vertexTexcoord;\n"
                             "   \n"
                             "   mat3 normalMatrix = mat3(viewMatrix);\n"
                             "   normal          = normalMatrix * vertexNormal;\n"
                             "}\n"
;
const char* printergrid_fragment = 
                             "#version 150 core\n"
                             " \n"
                             "out vec4 fragColor;\n"
                             "flat in vec2 flag;\n"
                             "uniform float visible;\n"
                             "uniform vec4 xshowcolor;\n"
                             "uniform vec4 yshowcolor;\n"
                             "uniform vec4 linecolor;\n"
                             "uniform vec4 xyIndexcolor;\n"
                             "uniform float highlight_index_x = 3.0;\n"
                             "uniform float highlight_index_y = 3.0;\n"
                             "void main() \n"
                             "{\n"
                             "	if(int(flag.x) == 0)\n"
                             "	{\n"
                             "		fragColor = yshowcolor;\n"
                             "	}\n"
                             "	else if(int(flag.y) == 0)\n"
                             "	{\n"
                             "		fragColor = xshowcolor;\n"
                             "	}\n"
                             "	else\n"
                             "	{\n"
                             "		//if((((int(flag.x/10.0))%4 > 0) || ((int(flag.y/10.0))%4 > 0)) && (visible == 0.0))\n"
                             "		//	discard;\n"
                             "		if(int(highlight_index_x) == int(flag.x) || int(highlight_index_y) == int(flag.y))\n"
                             "		{\n"
                             "			fragColor = xyIndexcolor; // vec4(1.0, 1.0, 0.0,1.0);\n"
                             "		}\n"
                             "		else\n"
                             "		{\n"
                             "			fragColor = linecolor;\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "\n"
                             "/*\n"
                             "	if (visible == 0.0)\n"
                             "	{\n"
                             "		discard;\n"
                             "	}\n"
                             "	else\n"
                             "	{\n"
                             "		if(((int(flag.x/10.0))%4 > 0) || ((int(flag.y/10.0))%4 > 0))\n"
                             "			//fragColor = showcolor;\n"
                             "			discard;\n"
                             "		else	\n"
                             "			fragColor = linecolor;\n"
                             "	}\n"
                             "	*/\n"
                             "}\n"
;
const char* printergrid_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec2 vertexFlag;\n"
                             "uniform mat4 modelViewProjection;\n"
                             "\n"
                             "flat out vec2 flag;\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "   flag = vertexFlag;\n"
                             "}\n"
;
const char* pure_fragment = 
                             "#version 150 core\n"
                             " \n"
                             "out vec4 fragColor;\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	fragColor = color;\n"
                             "}\n"
;
const char* pure_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "}\n"
;
const char* slicepreview_fragment = 
                             "#version 150 core \n"
                             "out vec4 fragment_color;\n"
                             "\n"
                             "in vec3 normal;\n"
                             "flat in vec2 flag;\n"
                             "flat in vec4 drawFlag;\n"
                             "in vec4 smoothFlag;\n"
                             "in vec3 viewDirection;\n"
                             "\n"
                             "uniform vec4 color = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "\n"
                             "uniform vec4 front_ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 front_diffuse = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 specular = vec4(0.2, 0.2, 0.2, 1.0);\n"
                             "\n"
                             "uniform vec3 light_direction1 = vec3(1.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform int showType = 0;\n"
                             "uniform int animation = 0;\n"
                             "\n"
                             "uniform vec4 clipValue;\n"
                             "uniform vec2 layershow;\n"
                             "uniform int layerstartflag_show;\n"
                             "\n"
                             "uniform vec4 typecolors[18];\n"
                             "uniform vec4 speedcolors[13];\n"
                             "uniform vec4 nozzlecolors[6];\n"
                             "\n"
                             "uniform int typecolorsshow[18];\n"
                             "\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 diffuse_color, vec4 core_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	diffuse_color         = diffuse_color * core_color;\n"
                             "	vec4 total_diffuse    = NdotL * diffuse_color;\n"
                             "	\n"
                             "//	/*\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower) * core_color;\n"
                             "//	*/\n"
                             "	\n"
                             "	return total_diffuse + specularColor;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(flag.x < clipValue.x || flag.x > clipValue.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x == clipValue.y && (flag.y < clipValue.z || flag.y > clipValue.w))\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x < layershow.x || flag.x > layershow.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(typecolorsshow[int(drawFlag.y)] == 0)\n"
                             "		discard;\n"
                             "	\n"
                             "	vec4 core_color = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "	vec3 lightDir = normalize(light_direction1);\n"
                             "	\n"
                             "	if(showType == 0)\n"
                             "	{\n"
                             "		int stype = int(drawFlag.x);\n"
                             "		core_color = speedcolors[stype];\n"
                             "	}\n"
                             "	else if(showType == 1)\n"
                             "		core_color = typecolors[int(drawFlag.y)];\n"
                             "	else if(showType == 2)\n"
                             "		core_color = nozzlecolors[int(drawFlag.z)];\n"
                             "		\n"
                             "	if(layerstartflag_show == 1 && smoothFlag.x > 0.0 && smoothFlag.x <= 0.2)\n"
                             "		core_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = front_ambient;\n"
                             "	vec4 diffuse_color    = front_diffuse;\n"
                             "	\n"
                             "	ambient_color 		  = ambient_color * core_color;\n"
                             "	\n"
                             "	vec4 light_color1     = directLight(lightDir, fnormal, diffuse_color, core_color);\n"
                             "	\n"
                             "	core_color = ambient_color + light_color1;\n"
                             "	core_color.a = color.a;\n"
                             "	\n"
                             "	if(animation > 0)\n"
                             "	{\n"
                             "		if(flag.x == clipValue.y)\n"
                             "		{\n"
                             "			core_color += vec4(0.3, 0.3, 0.3, 0.0);\n"
                             "		}\n"
                             "		else\n"
                             "		{\n"
                             "			core_color -= vec4(0.3, 0.3, 0.3, 0.0);\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	fragment_color = core_color;\n"
                             "}\n"
;
const char* slicepreview_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "in vec2 vertexFlag;\n"
                             "in vec4 vertexDrawFlag;\n"
                             "in vec4 vertexSmoothFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 normal;\n"
                             "flat out vec2 flag;\n"
                             "flat out vec4 drawFlag;\n"
                             "out vec4 smoothFlag;\n"
                             "out vec3 viewDirection;\n"
                             "\n"
                             "void main( void )\n"
                             "{	\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 world_position = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  world_position;\n"
                             "	flag = vertexFlag;\n"
                             "	drawFlag = vertexDrawFlag;\n"
                             "	smoothFlag = vertexSmoothFlag;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-world_position));\n"
                             "    normal          = mat3(modelview_matrix) * vertexNormal;\n"
                             "}\n"
;
const char* slicepreviewAD_fragment = 
                             "#version 150 core\n"
                             "out vec4 fragment_color; \n"
                             "\n"
                             "in vec3 normal;\n"
                             "flat in vec2 flag;\n"
                             "flat in vec4 drawFlag;\n"
                             "in vec3 viewDirection;\n"
                             "\n"
                             "uniform vec4 color = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "\n"
                             "uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
                             "uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "\n"
                             "uniform vec3 light_direction1 = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform int showType = 0;\n"
                             "uniform int animation = 0;\n"
                             "uniform int retractionShow = 0;\n"
                             "\n"
                             "uniform vec4 clipValue;\n"
                             "uniform vec2 layershow;\n"
                             "\n"
                             "uniform vec4 typecolors[16];\n"
                             "uniform vec4 speedcolors[13];\n"
                             "uniform vec4 nozzlecolors[9];\n"
                             "\n"
                             "uniform int typecolorsshow[15];\n"
                             "\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 diffuse_color, vec4 core_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	diffuse_color         = diffuse_color * core_color;\n"
                             "	vec4 total_diffuse    = NdotL * diffuse_color;\n"
                             "	\n"
                             "//	/*\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "//	*/\n"
                             "	\n"
                             "	return total_diffuse + specularColor;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(flag.x < clipValue.x || flag.x > clipValue.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x == clipValue.y && (flag.y < clipValue.z || flag.y > clipValue.w))\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x < layershow.x || flag.x > layershow.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(typecolorsshow[int(drawFlag.y)] == 0)\n"
                             "		discard;\n"
                             "	\n"
                             "	vec4 core_color = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "	\n"
                             "	if(showType == 0)\n"
                             "	{\n"
                             "		core_color = typecolors[int(drawFlag.y)];\n"
                             "		if(retractionShow == 1)\n"
                             "		{\n"
                             "			if(int(drawFlag.y) == 13 || int(drawFlag.y) == 14)//travel and react\n"
                             "				core_color = typecolors[15];	\n"
                             "		}\n"
                             "	}\n"
                             "	else if(showType == 1)\n"
                             "	{\n"
                             "		core_color = nozzlecolors[int(drawFlag.z)];\n"
                             "		if(retractionShow == 1)\n"
                             "		{\n"
                             "			if(int(drawFlag.z) == 6 || int(drawFlag.z) == 7)//travel and react\n"
                             "				core_color = nozzlecolors[8];	\n"
                             "		}\n"
                             "	}\n"
                             "	else if(showType == 2)\n"
                             "	{\n"
                             "		int stype = int(drawFlag.x);\n"
                             "		core_color = speedcolors[stype];\n"
                             "	}\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = front_ambient;\n"
                             "	vec4 diffuse_color    = front_diffuse;\n"
                             "	\n"
                             "	ambient_color 		  = ambient_color * core_color;\n"
                             "	\n"
                             "	vec4 light_color1     = directLight(light_direction1, fnormal, diffuse_color, core_color);\n"
                             "	\n"
                             "	core_color = ambient_color + light_color1;\n"
                             "	core_color.a = color.a;\n"
                             "	\n"
                             "	if(animation > 0)\n"
                             "	{\n"
                             "		if(flag.x == clipValue.y)\n"
                             "		{\n"
                             "			core_color += vec4(0.3, 0.3, 0.3, 0.0);\n"
                             "		}\n"
                             "		else\n"
                             "		{\n"
                             "			core_color -= vec4(0.3, 0.3, 0.3, 0.0);\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	fragment_color = core_color;\n"
                             "}\n"
;
const char* slicepreviewAD_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "in vec2 vertexFlag;\n"
                             "in vec4 vertexDrawFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 normal;\n"
                             "flat out vec2 flag;\n"
                             "flat out vec4 drawFlag;\n"
                             "out vec3 viewDirection;\n"
                             "\n"
                             "void main( void )\n"
                             "{	\n"
                             "	flag = vertexFlag;\n"
                             "	drawFlag = vertexDrawFlag;\n"
                             "\n"
                             "	mat4 usematrix = modelMatrix;\n"
                             "\n"
                             "	if((int(drawFlag.z) == 1 ||int(drawFlag.z) == 7) && int(drawFlag.w) == 1)\n"
                             "	{\n"
                             "		mat4 translate = mat4(\n"
                             "			1.0, 0.0, 0.0, 0.0,\n"
                             "			0.0, 1.0, 0.0, 0.0,\n"
                             "			0.0, 0.0, 1.0, 0.0,\n"
                             "			-35.0, 0.0, 0.0, 1.0\n"
                             "		);\n"
                             "		usematrix = modelMatrix * translate;\n"
                             "	}\n"
                             "	mat4 modelview_matrix = viewMatrix * usematrix;\n"
                             "	vec4 world_position = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  world_position;\n"
                             "	\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-world_position));\n"
                             "    normal          = mat3(modelview_matrix) * vertexNormal;\n"
                             "}\n"
;
const char* slicepreviewpath_fragment = 
                             "#version 150 core\n"
                             "out vec4 fragment_color; \n"
                             "\n"
                             "flat in vec2 flag;\n"
                             "uniform vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 clipValue;\n"
                             "uniform vec2 layershow;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(flag.x < clipValue.x || flag.x > clipValue.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x == clipValue.y && (flag.y < clipValue.z || flag.y > clipValue.w))\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x < layershow.x || flag.x > layershow.y)\n"
                             "		discard;\n"
                             "	\n"
                             "	vec4 core_color = color;\n"
                             "	fragment_color = core_color;\n"
                             "}\n"
;
const char* slicepreviewpath_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec2 vertexFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "flat out vec2 flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{	\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 world_position = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  world_position;\n"
                             "	flag = vertexFlag;\n"
                             "}\n"
;
const char* splitplane_fragment = 
                             "#version 150 core \n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "in vec3 worldPosition;\n"
                             "uniform vec4 color;\n"
                             "uniform vec3 clip[2];\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	if(worldPosition.z < clip[0].z || worldPosition.z > clip[1].z\n"
                             "		|| worldPosition.x < clip[0].x || worldPosition.x > clip[1].x\n"
                             "		|| worldPosition.y < clip[0].y || worldPosition.y > clip[1].y)\n"
                             "		discard;\n"
                             "		\n"
                             "	fragColor = color;\n"
                             "}\n"
;
const char* splitplane_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 worldPosition;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* support_fragment = 
                             "#version 150 core \n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "in vec3 worldPosition;\n"
                             "flat in float flag;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "uniform vec4 diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 stateColors[6];\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    vec4 color = stateColors[int(flag)];\n"
                             "\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	float NdotL 		  = dot(fnormal, lightDirection);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - lightDirection);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	\n"
                             "    fragmentColor = vec4(coreColor.rgb, color.a);\n"
                             "}\n"
;
const char* support_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "in float vertexFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec3 worldPosition;\n"
                             "flat out float flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "	flag			= vertexFlag;\n"
                             "	\n"
                             "	if(vertexFlag == 0.0)\n"
                             "	{\n"
                             "		gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "	}\n"
                             "}\n"
;
const char* supportpos_fragment = 
                             "#version 150 core \n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "noperspective in vec3 viewDirection;\n"
                             "noperspective in vec3 normal;\n"
                             "noperspective in vec3 worldPosition;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.4, 0.4, 0.4, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.6, 0.6, 0.6, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 stateColors = vec4(0.8, 0.5, 0.8, 1.0);\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight)\n"
                             "		discard;\n"
                             "		\n"
                             "	vec4 color = stateColors;	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	float NdotL 		  = max(dot(fnormal, lightDirection), 0.0);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = reflect(-lightDirection, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "\n"
                             "	fragmentColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* supportpos_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "noperspective out vec3 viewDirection;\n"
                             "noperspective out vec3 normal;\n"
                             "noperspective out vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* supportshow_fragment = 
                             "#version 150 core \n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "in vec3 worldPosition;\n"
                             "flat in float flag;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "uniform vec4 diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 stateColors[6];\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    vec4 color = stateColors[int(flag)];\n"
                             "//    color.a = flag;\n"
                             "\n"
                             "	if(worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight)\n"
                             "		discard;\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	float NdotL 		  = dot(fnormal, lightDirection);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - lightDirection);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	\n"
                             "//        if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "//	{\n"
                             "//		coreColor.g += 0.4;\n"
                             "//	}\n"
                             "	\n"
                             "//        if( abs(worldPosition.z - bottom) < 0.01 )\n"
                             "//        {\n"
                             "//                coreColor.g += 0.4;\n"
                             "//        }\n"
                             "	\n"
                             "        fragmentColor = vec4(coreColor.rgb, color.a);\n"
                             "}\n"
                             "\n"
;
const char* supportshow_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "in float vertexFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec3 worldPosition;\n"
                             "flat out float flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "	flag			= vertexFlag;\n"
                             "	\n"
                             "	if(vertexFlag == 0.0)\n"
                             "	{\n"
                             "		gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "	}\n"
                             "}\n"
;
const char* tex_fragment = 
                             "#version 150 core \n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "uniform sampler2D shapeTexture;\n"
                             "\n"
                             "in vec2 texcoord;\n"
                             "void main() \n"
                             "{\n"
                             "	vec4 color = texture(shapeTexture, texcoord);\n"
                             "	if(color.w == 1.0) discard;\n"
                             "	fragColor = vec4(color.xyz, 1.0);  \n"
                             "}\n"
;
const char* tex_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec2 vertexTexcoord;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "out vec2 texcoord;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "   texcoord = vertexTexcoord;\n"
                             "}\n"
;
const char* texshape_fragment = 
                             "#version 150 core \n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "uniform sampler2D shapeTexture;\n"
                             "\n"
                             "in vec2 texcoord;\n"
                             "void main() \n"
                             "{\n"
                             "	vec4 color = texture(shapeTexture, texcoord);\n"
                             "	if(color.a == 0.0)\n"
                             "	{\n"
                             "		color = vec4(0.44, 0.44, 0.44, 1.0);\n"
                             "	}\n"
                             "	fragColor = vec4(color.rgb, 1.0);  \n"
                             "}\n"
;
const char* texshape_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec2 vertexTexcoord;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "out vec2 texcoord;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "   texcoord = vertexTexcoord;\n"
                             "}\n"
;
const char* text_fragment = 
                             "#version 150 core \n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "uniform vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	fragColor = color;\n"
                             "}\n"
;
const char* text_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "}\n"
;
const char* xyzIndicator_fragment = 
                             "#version 150 core\n"
                             " \n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "in vec3 worldPosition;\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "uniform vec3 lightDirection = vec3(1.0, 0.0, 0.0);\n"
                             "\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "		\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "	\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient, diffuse, specular);	\n"
                             "	\n"
                             "	fragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* xyzIndicator_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec3 worldPosition;\n"
                             "out vec3  worldWater;\n"
                             "\n"
                             "void main( void ) \n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "	gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "	normal          = normalMatrix * vertexNormal;\n"
                             "	\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "	\n"
                             "}\n"
;
const char* zproject_fragment = 
                             "#version 150 core \n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "uniform int cameraDir;\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(cameraDir == 0)\n"
                             "		discard;\n"
                             "		\n"
                             "	fragmentColor = vec4(0.1451, 0.1569, 0.1647, 1.0);\n"
                             "}\n"
;
const char* zproject_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform float projectZ = 0.01;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    vec4 tworldPosition = modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "	tworldPosition.z = projectZ;\n"
                             "    gl_Position = projectionMatrix * viewMatrix *  tworldPosition;\n"
                             "}\n"
;
//-----------gl3.0 code array.
const char* shader_code_array[77] = {
	admodel_fragment,
	admodel_vert,
	bottomface_fragment,
	bottomface_vert,
	boxclippure_fragment,
	boxclippure_vert,
	chunk_fragment,
	chunk_vert,
	color_fragment,
	color_vert,
	dlpsupportindicator_fragment,
	dlpsupportindicator_vert,
	finephong_fragment,
	finephong_vert,
	finephongtex_fragment,
	finephongtex_vert,
	glcomp1_fragment,
	glcomp1_vert,
	manipulate_fragment,
	manipulate_vert,
	model_fragment,
	model_vert,
	modeldlp_fragment,
	modeldlp_vert,
	modelline_fragment,
	modelline_vert,
	modelselect_fragment,
	modelselect_vert,
	modelsimple_fragment,
	modelsimple_vert,
	modelSupport_fragment,
	modelSupport_vert,
	modelwireframe_fragment,
	modelwireframe_geom,
	modelwireframe_vert,
	moon_fragment,
	moon_vert,
	overlay_fragment,
	overlay_vert,
	photo_fragment,
	photo_vert,
	pickFace_fragment,
	pickFace_vert,
	pickFaceChunk_fragment,
	pickFaceChunk_vert,
	pickFaceFlag_fragment,
	pickFaceFlag_vert,
	printerbottom_fragment,
	printerbottom_vert,
	printergrid_fragment,
	printergrid_vert,
	pure_fragment,
	pure_vert,
	slicepreview_fragment,
	slicepreview_vert,
	slicepreviewAD_fragment,
	slicepreviewAD_vert,
	slicepreviewpath_fragment,
	slicepreviewpath_vert,
	splitplane_fragment,
	splitplane_vert,
	support_fragment,
	support_vert,
	supportpos_fragment,
	supportpos_vert,
	supportshow_fragment,
	supportshow_vert,
	tex_fragment,
	tex_vert,
	texshape_fragment,
	texshape_vert,
	text_fragment,
	text_vert,
	xyzIndicator_fragment,
	xyzIndicator_vert,
	zproject_fragment,
	zproject_vert
};
//-------------programs!
struct ProgramDef
{
	const char* name;
	int vIndex;
    int tcsIndex;
    int tesIndex;
	int gIndex;
	int fIndex;
};
int programs_meta_size = 38;
ProgramDef programs_meta[38] = {
  { "admodel" , 1  ,  -1   ,  -1   ,  -1   , 0  },
   { "bottomface" , 3  ,  -1   ,  -1   ,  -1   , 2  },
   { "boxclippure" , 5  ,  -1   ,  -1   ,  -1   , 4  },
   { "chunk" , 7  ,  -1   ,  -1   ,  -1   , 6  },
   { "color" , 9  ,  -1   ,  -1   ,  -1   , 8  },
   { "dlpsupportindicator" , 11  ,  -1   ,  -1   ,  -1   , 10  },
   { "finephong" , 13  ,  -1   ,  -1   ,  -1   , 12  },
   { "finephongtex" , 15  ,  -1   ,  -1   ,  -1   , 14  },
   { "glcomp1" , 17  ,  -1   ,  -1   ,  -1   , 16  },
   { "manipulate" , 19  ,  -1   ,  -1   ,  -1   , 18  },
   { "model" , 21  ,  -1   ,  -1   ,  -1   , 20  },
   { "modelSupport" , 31  ,  -1   ,  -1   ,  -1   , 30  },
   { "modeldlp" , 23  ,  -1   ,  -1   ,  -1   , 22  },
   { "modelline" , 25  ,  -1   ,  -1   ,  -1   , 24  },
   { "modelselect" , 27  ,  -1   ,  -1   ,  -1   , 26  },
   { "modelsimple" , 29  ,  -1   ,  -1   ,  -1   , 28  },
   { "modelwireframe" , 34  ,  -1   ,  -1   , 33  , 32  },
   { "moon" , 36  ,  -1   ,  -1   ,  -1   , 35  },
   { "overlay" , 38  ,  -1   ,  -1   ,  -1   , 37  },
   { "photo" , 40  ,  -1   ,  -1   ,  -1   , 39  },
   { "pickFace" , 42  ,  -1   ,  -1   ,  -1   , 41  },
   { "pickFaceChunk" , 44  ,  -1   ,  -1   ,  -1   , 43  },
   { "pickFaceFlag" , 46  ,  -1   ,  -1   ,  -1   , 45  },
   { "printerbottom" , 48  ,  -1   ,  -1   ,  -1   , 47  },
   { "printergrid" , 50  ,  -1   ,  -1   ,  -1   , 49  },
   { "pure" , 52  ,  -1   ,  -1   ,  -1   , 51  },
   { "slicepreview" , 54  ,  -1   ,  -1   ,  -1   , 53  },
   { "slicepreviewAD" , 56  ,  -1   ,  -1   ,  -1   , 55  },
   { "slicepreviewpath" , 58  ,  -1   ,  -1   ,  -1   , 57  },
   { "splitplane" , 60  ,  -1   ,  -1   ,  -1   , 59  },
   { "support" , 62  ,  -1   ,  -1   ,  -1   , 61  },
   { "supportpos" , 64  ,  -1   ,  -1   ,  -1   , 63  },
   { "supportshow" , 66  ,  -1   ,  -1   ,  -1   , 65  },
   { "tex" , 68  ,  -1   ,  -1   ,  -1   , 67  },
   { "texshape" , 70  ,  -1   ,  -1   ,  -1   , 69  },
   { "text" , 72  ,  -1   ,  -1   ,  -1   , 71  },
   { "xyzIndicator" , 74  ,  -1   ,  -1   ,  -1   , 73  },
   { "zproject" , 76  ,  -1   ,  -1   ,  -1   , 75  },
 };
