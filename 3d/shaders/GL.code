//------------ gles code
const char* gles_admodel_fragment = 
                             "/* admodel.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.4, 0.4, 0.4, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.6, 0.6, 0.6, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float error;\n"
                             "\n"
                             "uniform float sceneBottom;\n"
                             "uniform float sceneTop;\n"
                             "uniform sampler1D shapeTexture;\n"
                             "\n"
                             "uniform int fanzhuan = 0;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform vec4 stateColors[5];\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower);\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "vec4 changeColor(vec3 wordPos)\n"
                             "{\n"
                             "	float delta = sceneTop - sceneBottom;\n"
                             "	if(delta < 1.0)\n"
                             "		delta = 1.0;\n"
                             "	\n"
                             "	float texCoord = (wordPos.z - sceneBottom)/delta;\n"
                             "	return texture(shapeTexture, texCoord);\n"
                             "	//return vec4(texCoord, 0.0, 0.0, 1.0);\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec4 color = stateColors[int(state)];	\n"
                             "	if(error == 1.0)\n"
                             "		color = stateColors[3];\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = ambient;\n"
                             "	vec4 diffuse_color    = diffuse;\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec4 coreColor = directLight(lightDirection, fnormal, color, ambient_color, diffuse_color, specular_color);\n"
                             "	if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "	{\n"
                             "		coreColor.g += 0.4;\n"
                             "	}\n"
                             "	\n"
                             "	coreColor += changeColor(worldPosition);\n"
                             "	\n"
                             "	int fz = fanzhuan % 2;\n"
                             "	\n"
                             "	if(fz == 0)\n"
                             "	{\n"
                             "		if(!gl_FrontFacing)\n"
                             "		{\n"
                             "			coreColor.rgb = vec3(0.65, 0.75, 0.65) - coreColor.rgb;\n"
                             "		}\n"
                             "	}\n"
                             "	else\n"
                             "	{\n"
                             "		if(gl_FrontFacing)\n"
                             "		{\n"
                             "			coreColor.rgb = vec3(0.65, 0.75, 0.65) - coreColor.rgb;\n"
                             "		}\n"
                             "	}\n"
                             "   \n"
                             "	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_admodel_vert = 
                             "/* admodel.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix  = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition   = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position           = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirection         = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix     = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normal          	  = normalMatrix * vertexNormal;\n"
                             "    worldPosition   	  = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* gles_blur_fragment = 
                             "#version 150 core\n"
                             "in vec2 texCoord0;\n"
                             "uniform int ssa; \n"
                             "uniform int need_thres; \n"
                             "uniform vec2 img_size; \n"
                             "uniform vec2 clrThreshold;\n"
                             "uniform sampler2D samplerTexture0;\n"
                             "uniform sampler2D samplerTexture1;\n"
                             "uniform sampler2D samplerTexture2;\n"
                             "out vec4 fragData0;\n"
                             "out vec4 fragData1;\n"
                             "out vec4 fragData2;\n"
                             "\n"
                             "vec4 blur(sampler2D postTexture, int lpos, int rpos, float bili)\n"
                             "{\n"
                             "	vec4 retOutput = vec4(0.0, 0.0, 0.0, 0.0);\n"
                             "	vec4 clrtemp = vec4(0.0, 0.0, 0.0, 0.0); \n"
                             "	for(int i = -lpos; i <= rpos; i++) \n"
                             "	{ \n"
                             "		for(int j = -lpos; j <= rpos; j++) \n"
                             "		{ \n"
                             "			vec2 offset = vec2(float(i)/img_size.x, float(j)/img_size.y); \n"
                             "			vec4 temp = texture(postTexture, texCoord0+offset) / bili; \n"
                             "			clrtemp += temp; \n"
                             "		} \n"
                             "	} \n"
                             "	clrtemp.a = 1.0;  \n"
                             "	if(need_thres > 0) { \n"
                             "		vec2 thresholdvalue = vec2(clrThreshold.x, clrThreshold.y);\n"
                             "		float rangratio = thresholdvalue.y-thresholdvalue.x;\n"
                             "		if(clrtemp.r >= 0.003 && clrtemp.r <= 0.997)\n"
                             "			retOutput = vec4(thresholdvalue.x + clrtemp.r * rangratio, 0.0, 0.0, 1.0);\n"
                             "			//retOutput = texture(postTexture, texCoord0);\n"
                             "		else \n"
                             "			retOutput = clrtemp; \n"
                             "	} \n"
                             "	else if(need_thres == 0) { \n"
                             "		retOutput = clrtemp;  \n"
                             "	} \n"
                             "	else { \n"
                             "		clrtemp = texture(postTexture, texCoord0); \n"
                             "		clrtemp.a = 1.0; \n"
                             "		retOutput = clrtemp;  \n"
                             "	} \n"
                             "	\n"
                             "	return retOutput;\n"
                             "}\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	float bbili = float(ssa * ssa); \n"
                             "	int llpos = ssa/2; \n"
                             "	int rrpos = (ssa-1)/2; \n"
                             "	fragData0 = blur(samplerTexture0, llpos, rrpos, bbili);\n"
                             "	fragData1 = blur(samplerTexture1, llpos, rrpos, bbili);\n"
                             "	fragData2 = blur(samplerTexture2, llpos, rrpos, bbili);\n"
                             "}\n"
;
const char* gles_blur_vert = 
                             "#version 150 core\n"
                             "in vec3 vertexPosition;\n"
                             "in vec2 vertexTexCoord;\n"
                             "out vec2 texCoord0;\n"
                             "void main()\n"
                             "{\n"
                             "   gl_Position = vec4(vertexPosition, 1.0);\n"
                             "	texCoord0 = vertexTexCoord;\n"
                             "}\n"
;
const char* gles_bottomface_fragment = 
                             "/* bottomface.fragment */\n"
                             "precision mediump float;\n"
                             "varying vec3 normal;\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	vec4 finalcolor = color;\n"
                             "\n"
                             "	vec3 fgnormal 		  =	normalize(normal);\n"
                             "	if(dot(fgnormal, vec3(0.0, 0.0, -1.0)) > 0.0)\n"
                             "	{\n"
                             "		finalcolor.a = 0.0;\n"
                             "	}\n"
                             "	gl_FragColor = finalcolor;\n"
                             "	\n"
                             "}\n"
;
const char* gles_bottomface_vert = 
                             "/* bottomface.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec2 texcoord;\n"
                             "varying vec3 normal;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "   \n"
                             "   mat3 normalMatrix = mat3(viewMatrix);\n"
                             "   normal          = normalMatrix * vertexNormal;\n"
                             "}\n"
;
const char* gles_boxclippure_fragment = 
                             "/* boxclippure.fragment */\n"
                             "precision mediump float;\n"
                             "varying vec3 worldPosition;\n"
                             "uniform vec4 color;\n"
                             "uniform vec3 clip[2];\n"
                             "\n"
                             "uniform float intensity; // = 5.0;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	gl_FragColor = color;\n"
                             "	#if 0\n"
                             "	if ( worldPosition.z < clip[0].z || worldPosition.z > clip[1].z\n"
                             "        || worldPosition.x < clip[0].x || worldPosition.x > clip[1].x\n"
                             "        || worldPosition.y < clip[0].y || worldPosition.y > clip[1].y) \n"
                             "	{\n"
                             "		discard;\n"
                             "	} else {\n"
                             "	\n"
                             "		float x = min( abs(worldPosition.x - clip[0].x), abs(worldPosition.x - clip[1].x) );\n"
                             "		float y = min( abs(worldPosition.y - clip[0].y), abs(worldPosition.y - clip[1].y) );\n"
                             "		float z = min( abs(worldPosition.z - clip[0].z), abs(worldPosition.z - clip[1].z) );\n"
                             "		\n"
                             "		x = min(x, y);\n"
                             "		x = min(x, z);\n"
                             "\n"
                             "		float k = clamp(x * intensity, 0.0, 1.0);\n"
                             "		gl_FragColor = vec4(color.rgb, color.a * k);\n"
                             "	}\n"
                             "	#endif\n"
                             "}\n"
;
const char* gles_boxclippure_vert = 
                             "/* boxclippure.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* gles_chunk_fragment = 
                             "/* chunk.fragment */\n"
                             "\n"
                             "uniform vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n"
                             "varying float flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(flag == 0.0)\n"
                             "		discard;	\n"
                             "\n"
                             "	gl_FragColor = color;\n"
                             "}\n"
;
const char* gles_chunk_vert = 
                             "/* chunk.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "attribute float vertexFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying float flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	flag			= vertexFlag;\n"
                             "}\n"
;
const char* gles_color_fragment = 
                             "/* color.fragment */\n"
                             "\n"
                             "varying vec4 fcolor;\n"
                             "void main() \n"
                             "{\n"
                             "	gl_FragColor = fcolor;\n"
                             "}\n"
;
const char* gles_color_vert = 
                             "/* color.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec4 vertexColor;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "varying vec4 fcolor;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "   fcolor = vertexColor;\n"
                             "}\n"
;
const char* gles_dlpsupportindicator_fragment = 
                             "/* DlpSupportIndicator Fragment*/\n"
                             "precision mediump float; \n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "const vec4 ambient = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "const vec4 diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "const vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "const float specularPower = 12.0;\n"
                             "\n"
                             "const vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	float NdotL 		  = dot(fnormal, lightDirection);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - lightDirection);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;	\n"
                             "	\n"
                             "    gl_FragColor = vec4(coreColor.rgb, color.a);\n"
                             "}\n"
                             "\n"
;
const char* gles_dlpsupportindicator_vert = 
                             "/* DlpSupportIndicator Vertex*/\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* gles_finephong_fragment = 
                             "/* finephong.fragment */\n"
                             "precision mediump float;\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "\n"
                             "uniform vec4 color; // = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "const vec4 ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
                             "const vec4 diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "const vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "const float specularPower = 128.0;\n"
                             "\n"
                             "const vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec4 _color			  = color;\n"
                             "	if(!gl_FrontFacing)\n"
                             "    {\n"
                             "		_color = vec4(0.65, 0.0, 0.0, 1.0);\n"
                             "    }\n"
                             "	\n"
                             "	float NdotL 		  = max(dot(fnormal, lightDirection), 0.0);\n"
                             "	vec4 ambientColor 	  = ambient * _color;\n"
                             "	vec3 freflection      = reflect(-lightDirection, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * _color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_finephong_vert = 
                             "/* finephong.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 worldPosition = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  worldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-worldPosition));\n"
                             "    normal          = mat3(modelview_matrix) * vertexNormal;\n"
                             "}\n"
;
const char* gles_finephongtex_fragment = 
                             "/* finephongtex.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec2 texcoord;\n"
                             "\n"
                             "uniform sampler2D shapeTexture;\n"
                             "\n"
                             "uniform vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform float specularPower = 128.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform float useAzi = 0.0;\n"
                             "\n"
                             "vec2 azi_to_equ(vec2 tc)\n"
                             "{\n"
                             "	vec2 zaiTC = tc;\n"
                             "	if(useAzi == 1.0)\n"
                             "	{\n"
                             "		float PI = 3.1415926;\n"
                             "		vec2 t = vec2(tc.x - 0.5, tc.y - 0.5);\n"
                             "		float alpha = atan(t.y, t.x);\n"
                             "		float r = length(t);\n"
                             "		if(r > 0.5)\n"
                             "			zaiTC = vec2(-1.0, -1.0);\n"
                             "		else\n"
                             "		{\n"
                             "			float beta = 2 * PI * r;\n"
                             "			float x_ = 0.5 + 0.5 * alpha / PI;\n"
                             "			float y_= 1 - beta / PI;\n"
                             "			zaiTC = vec2(x_, y_);\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	return zaiTC;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec4 _color			  = color * texture2D(shapeTexture, azi_to_equ(texcoord));\n"
                             "	if(!gl_FrontFacing)\n"
                             "    {\n"
                             "		_color = vec4(0.65, 0.0, 0.0, 1.0);\n"
                             "    }\n"
                             "	\n"
                             "	float NdotL 		  = max(dot(fnormal, lightDirection), 0.0);\n"
                             "	vec4 ambientColor 	  = ambient * _color;\n"
                             "	vec3 freflection      = reflect(-lightDirection, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * _color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_finephongtex_vert = 
                             "/* finephongtex.vert */\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "attribute vec2 vertexTexcoord;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec2 texcoord;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 worldPosition = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  worldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-worldPosition));\n"
                             "    normal          = mat3(modelview_matrix) * vertexNormal;\n"
                             "	texcoord = vertexTexcoord;\n"
                             "}\n"
;
const char* gles_glcomp1_fragment = 
                             "/* glcomp1.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 gnormal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection));\n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec4 color = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec3 fgnormal 		  =	normalize(gnormal);\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "\n"
                             "	if(!gl_FrontFacing)\n"
                             "	{\n"
                             "		color = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "		fnormal = - fnormal;\n"
                             "	}\n"
                             "	\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient, diffuse, specular);\n"
                             "	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_glcomp1_vert = 
                             "/* glcomp1.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 gnormal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "    gnormal        = mat3(modelMatrix) * vertexNormal;\n"
                             "		\n"
                             "    worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* gles_gpuantialiasing_fragment = 
                             "#version 330 core\n"
                             "\n"
                             "out vec4 fragColor0;\n"
                             "out vec4 fragColor1;\n"
                             "out vec4 fragColor2;\n"
                             "in vec2 texCoord0;\n"
                             "uniform vec2 textureSize;\n"
                             "uniform sampler2D mainTexture0;\n"
                             "uniform sampler2D mainTexture1;\n"
                             "uniform sampler2D mainTexture2;\n"
                             "uniform int antiflag;\n"
                             "\n"
                             "#ifndef FXAA_REDUCE_MIN  \n"
                             "#define FXAA_REDUCE_MIN   (1.0/ 128.0)  \n"
                             "#endif  \n"
                             "#ifndef FXAA_REDUCE_MUL  \n"
                             "#define FXAA_REDUCE_MUL   (1.0 / 8.0)  \n"
                             "#endif  \n"
                             "#ifndef FXAA_SPAN_MAX  \n"
                             "#define FXAA_SPAN_MAX     8.0  \n"
                             "#endif\n"
                             "  \n"
                             "vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,  \n"
                             "	vec2 v_rgbNW, vec2 v_rgbNE,  \n"
                             "	vec2 v_rgbSW, vec2 v_rgbSE,  \n"
                             "	vec2 v_rgbM) \n"
                             "{  \n"
                             "	vec4 color;  \n"
                             "	mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);  \n"
                             "	vec3 rgbNW = texture(tex, v_rgbNW).xyz;  \n"
                             "	vec3 rgbNE = texture(tex, v_rgbNE).xyz;  \n"
                             "	vec3 rgbSW = texture(tex, v_rgbSW).xyz;  \n"
                             "	vec3 rgbSE = texture(tex, v_rgbSE).xyz;  \n"
                             "	vec4 texColor = texture(tex, v_rgbM);  \n"
                             "	vec3 rgbM = texColor.xyz;  \n"
                             "	vec3 luma = vec3(0.299, 0.587, 0.114);  \n"
                             "	float lumaNW = dot(rgbNW, luma);  \n"
                             "	float lumaNE = dot(rgbNE, luma);  \n"
                             "	float lumaSW = dot(rgbSW, luma);  \n"
                             "	float lumaSE = dot(rgbSE, luma);  \n"
                             "	float lumaM = dot(rgbM, luma);  \n"
                             "	float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));  \n"
                             "	float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));  \n"
                             "\n"
                             "	mediump vec2 dir;  \n"
                             "	dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));  \n"
                             "	dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));  \n"
                             "\n"
                             "	float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);  \n"
                             "\n"
                             "	float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);  \n"
                             "	dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),  \n"
                             "		max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),  \n"
                             "			dir * rcpDirMin)) * inverseVP;  \n"
                             "\n"
                             "	vec3 rgbA = 0.5 * (  \n"
                             "		texture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +  \n"
                             "		texture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);  \n"
                             "	vec3 rgbB = rgbA * 0.5 + 0.25 * (  \n"
                             "		texture(tex, fragCoord * inverseVP + dir * -0.5).xyz +  \n"
                             "		texture(tex, fragCoord * inverseVP + dir * 0.5).xyz);  \n"
                             "\n"
                             "	float lumaB = dot(rgbB, luma);  \n"
                             "	if ((lumaB < lumaMin) || (lumaB > lumaMax))  \n"
                             "	color = vec4(rgbA, texColor.a);  \n"
                             "	else  \n"
                             "	color = vec4(rgbB, texColor.a);  \n"
                             "	return color;  \n"
                             "}  \n"
                             "\n"
                             "void texcoords(vec2 fragCoord, vec2 resolution,  \n"
                             "	out vec2 v_rgbNW, out vec2 v_rgbNE,  \n"
                             "	out vec2 v_rgbSW, out vec2 v_rgbSE,  \n"
                             "	out vec2 v_rgbM) \n"
                             "{  \n"
                             "	vec2 inverseVP = 1.0 / resolution.xy;  \n"
                             "	v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;  \n"
                             "	v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;  \n"
                             "	v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;  \n"
                             "	v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;  \n"
                             "	v_rgbM = vec2(fragCoord * inverseVP);  \n"
                             "}\n"
                             "\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	if(antiflag == 1)\n"
                             "	{\n"
                             "		vec2 fragCoord = gl_FragCoord.xy;\n"
                             "		\n"
                             "		vec2 v_rgbNW;\n"
                             "		vec2 v_rgbNE;\n"
                             "		vec2 v_rgbSW;\n"
                             "		vec2 v_rgbSE;\n"
                             "		vec2 v_rgbM;\n"
                             "		\n"
                             "		texcoords(fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
                             "		\n"
                             "		fragColor0 = fxaa(mainTexture0, fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
                             "		fragColor1 = fxaa(mainTexture1, fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
                             "		fragColor2 = fxaa(mainTexture2, fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
                             "	\n"
                             "	}\n"
                             "	else\n"
                             "	{\n"
                             "		fragColor0 = texture2D(mainTexture0, texCoord0);\n"
                             "		fragColor1 = texture2D(mainTexture1, texCoord0);\n"
                             "		fragColor2 = texture2D(mainTexture2, texCoord0);\n"
                             "	}\n"
                             "}\n"
;
const char* gles_gpuantialiasing_vert = 
                             "#version 330 core\n"
                             "in vec3 vertexPosition;\n"
                             "in vec2 vertexTexCoord;\n"
                             "out vec2 texCoord0;\n"
                             "void main()\n"
                             "{\n"
                             "   gl_Position = vec4(vertexPosition, 1.0);\n"
                             "   texCoord0 = vertexTexCoord;\n"
                             "}\n"
;
const char* gles_manipulate_fragment = 
                             "/* manipulate.fragment */\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "uniform vec4 changecolor;\n"
                             "uniform int mt;\n"
                             "\n"
                             "uniform float state;\n"
                             "void main() \n"
                             "{\n"
                             "	if(mt == 0)\n"
                             "	{\n"
                             "		gl_FragColor = color * state;\n"
                             "	}\n"
                             "	else if(mt == 1)\n"
                             "	{\n"
                             "		gl_FragColor = color + changecolor * state;\n"
                             "	}\n"
                             "	\n"
                             "}\n"
;
const char* gles_manipulate_vert = 
                             "/* manipulate.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "}\n"
;
const char* gles_model_fragment = 
                             "/* model.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 gnormal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying vec3 worldWater;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform int lightingEnable = 1;\n"
                             "uniform float transparency = 1.0;\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "uniform float error;\n"
                             "uniform float supportCos = 0.5;\n"
                             "\n"
                             "uniform int hoverState = 0;\n"
                             "uniform int waterState = 0;\n"
                             "uniform int fanzhuan = 0;\n"
                             "uniform int checkscope = 1;\n"
                             "\n"
                             "uniform float zcha = 0.01;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform float nozzle;\n"
                             "uniform vec4 stateColors[6];\n"
                             "uniform vec4 customColor;\n"
                             "\n"
                             "bool frontFacing()\n"
                             "{\n"
                             "        vec3 fdx = dFdx(worldPosition);\n"
                             "        vec3 fdy = dFdy(worldPosition);\n"
                             "        return dot(gnormal, cross(fdx, fdy)) > 0.0;\n"
                             "} \n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return lightingEnable * (ambient_color + diffuse_color + specular_color) + (1 - lightingEnable) * core_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(checkscope > 0 && (worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight))\n"
                             "		discard;\n"
                             "\n"
                             "	int stateInt = int(state);\n"
                             "	vec4 color;\n"
                             "	if (stateInt < 5)\n"
                             "		color = stateColors[stateInt];\n"
                             "	else\n"
                             "		color = customColor;\n"
                             "	\n"
                             "	if(error == 1.0)\n"
                             "		color = stateColors[3];	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = ambient;\n"
                             "	vec4 diffuse_color    = diffuse;\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient_color, diffuse_color, specular_color);\n"
                             "	\n"
                             "	vec3 fgnormal 		  =	normalize(gnormal);\n"
                             "	\n"
                             "	if(checkscope > 0)\n"
                             "	{\n"
                             "		if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "		if( abs(worldPosition.z - bottom) < 0.05 )\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	\n"
                             "	if(hoverState > 0)\n"
                             "	{\n"
                             "		float v = dot(fgnormal, vec3(0.0, 0.0, -1.0));\n"
                             "		if(v >= supportCos)\n"
                             "		{\n"
                             "			coreColor.r += 0.8 * v;\n"
                             "		}\n"
                             "		\n"
                             "		if(waterState == 1)\n"
                             "		{\n"
                             "			if(abs(worldPosition.z - worldWater.z) < zcha)\n"
                             "			{\n"
                             "				coreColor = vec4(0.1, 0.1, 0.1, 1.0);\n"
                             "			}\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	coreColor.rgb = coreColor.rgb + vec3(0.1, -0.1, 0.0) * nozzle;\n"
                             "\n"
                             "	if(!frontFacing())\n"
                             "	{\n"
                             "		color = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "		color.a = 1.0;\n"
                             "		vec3 fbnormal = -fnormal;\n"
                             "		vec4 ambient_color_t 	  = ambient + vec4(0.03, 0.03, 0.03, 0.0);\n"
                             "		vec4 diffuse_color_t    = diffuse;\n"
                             "		vec4 specular_color_t   = specular;\n"
                             "		coreColor = directLight(lightDir, fbnormal, color, ambient_color_t, diffuse_color_t, specular_color_t);\n"
                             "	}\n"
                             "\n"
                             "    //int fz = fanzhuan % 2;\n"
                             "    //   \n"
                             "    //if(fz == 0)\n"
                             "    //{\n"
                             "    //    if(! frontFacing())\n"
                             "    //    {\n"
                             "    //        //coreColor = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "	//		coreColor.a = 1.0;\n"
                             "    //    }\n"
                             "    //}\n"
                             "    //else\n"
                             "    //{\n"
                             "    //    if(frontFacing())\n"
                             "    //    {\n"
                             "    //        //coreColor = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "	//		coreColor.a = 1.0;\n"
                             "    //    }\n"
                             "    //}\n"
                             "\n"
                             "	gl_FragColor = vec4(coreColor.rgb, transparency);\n"
                             "}\n"
;
const char* gles_model_vert = 
                             "/* model.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform vec3 water;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 gnormal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying vec3  worldWater;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "    gnormal        = mat3(modelMatrix) * vertexNormal;\n"
                             "		\n"
                             "    worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "    worldWater = water;\n"
                             "}\n"
;
const char* gles_modeldlp_fragment = 
                             "/* modeldlp.fragment */\n"
                             "precision mediump float;\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 gnormal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "uniform int state;\n"
                             "uniform float error;\n"
                             "\n"
                             "const vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "const vec4 diffuse = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "const vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "const float specularPower = 12.0;\n"
                             "const vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 clipPlane1;\n"
                             "uniform vec4 clipPlane2;\n"
                             "\n"
                             "const int checkScope = 1;\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float supportCos; // = 0.5;\n"
                             "\n"
                             "uniform int hoverState; // = 0;\n"
                             "uniform int waterState; // = 0;\n"
                             "\n"
                             "const float zcha = 0.1;\n"
                             "\n"
                             "uniform vec4 stateColors[6];\n"
                             "uniform vec3 water;\n"
                             "\n"
                             "float distance2Plane(vec3 position, vec4 plane)\n"
                             "{\n"
                             "	vec3 p = position - vec3(0.0, 0.0, plane.w);\n"
                             "	return dot(p, plane.xyz);\n"
                             "}\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(distance2Plane(worldPosition, clipPlane1) < 0.0)\n"
                             "		discard;\n"
                             "\n"
                             "	if(distance2Plane(worldPosition, clipPlane2) < 0.0)\n"
                             "		discard;\n"
                             "		\n"
                             "	vec4 color = stateColors[state];\n"
                             "	color = error * stateColors[3] + (1.0 - error) * color;	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec3 fgnormal 		  =	normalize(gnormal);\n"
                             "		\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "\n"
                             "	if(!gl_FrontFacing)\n"
                             "	{\n"
                             "		color = vec4(stateColors[5].xyz, 1.0);\n"
                             "		fnormal = - fnormal;\n"
                             "	}\n"
                             "	\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient, diffuse, specular);	\n"
                             "	if(checkScope > 0)\n"
                             "	{\n"
                             "		if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < 0.1 || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	\n"
                             "	if(hoverState > 0)\n"
                             "	{\n"
                             "		float v = dot(fgnormal, vec3(0.0, 0.0, -1.0));\n"
                             "		if(v >= supportCos)\n"
                             "		{\n"
                             "			coreColor.r += 0.8 * v;\n"
                             "		}\n"
                             "		\n"
                             "		if(waterState == 1)\n"
                             "		{\n"
                             "			if(abs(worldPosition.z - water.z) < zcha)\n"
                             "			{\n"
                             "				coreColor = vec4(0.1, 0.1, 0.1, 1.0);\n"
                             "			}\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_modeldlp_vert = 
                             "/* modeldlp.vert */\n"
                             "\n"
                             "attribute vec4 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 gnormal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying vec3  worldWater;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition.xyz, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "    gnormal        = mat3(modelMatrix) * vertexNormal;\n"
                             "		\n"
                             "    worldPosition   = vec3(modelMatrix * vec4(vertexPosition.xyz, 1.0));\n"
                             "}\n"
;
const char* gles_modelline_fragment = 
                             "/* modelline.fragment */\n"
                             "\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "uniform vec3 machineCube;\n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "uniform float error;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform vec4 stateColors[5];\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight)\n"
                             "		discard;\n"
                             "\n"
                             "	vec4 color = stateColors[int(state)];	\n"
                             "	//if(abs(worldPosition.x) > machineCube.x/2.0 || abs(worldPosition.y) > machineCube.y/2.0 ||  worldPosition.z > machineCube.z || worldPosition.z < 0.0)\n"
                             "    //   color = stateColors[3];\n"
                             "	if(error == 1.0)\n"
                             "		color = stateColors[3];\n"
                             "	\n"
                             "	gl_FragColor = vec4(0.1, 0.1, 0.1, 1.0);\n"
                             "}\n"
;
const char* gles_modelline_vert = 
                             "/* modelline.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* gles_modelselect_fragment = 
                             "/* modelselect.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.4, 0.4, 0.4, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.6, 0.6, 0.6, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "uniform float error;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform float nozzle;\n"
                             "uniform vec4 stateColors[4];\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower);\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight)\n"
                             "		discard;\n"
                             "\n"
                             "	vec4 color = stateColors[int(state)];	\n"
                             "	if(error == 1.0)\n"
                             "		color = stateColors[3];\n"
                             "		\n"
                             "	vec4 back_color = color;\n"
                             "//	back_color.rgb = vec3(1.0, 1.0, 1.0) - back_color.rgb;\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = ambient;\n"
                             "	vec4 diffuse_color    = diffuse;\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec4 coreColor = directLight(lightDirection, fnormal, color, ambient_color, diffuse_color, specular_color);\n"
                             "	vec4 coreColor_b = directLight(lightDirection, -fnormal, back_color, ambient_color - vec4(0.2, 0.2, 0.2, 0.0), diffuse_color, specular_color);\n"
                             "	\n"
                             "	coreColor.g += 0.4;\n"
                             "	coreColor.r += 0.4;\n"
                             "	\n"
                             "	coreColor_b.g += 0.2;\n"
                             "	coreColor_b.r += 0.2;\n"
                             "	\n"
                             "	coreColor.rgb = coreColor.rgb + vec3(0.1, -0.1, 0.0) * nozzle;\n"
                             "	coreColor_b.rgb = coreColor_b.rgb + vec3(0.1, -0.1, 0.0) * nozzle;\n"
                             "	\n"
                             "	if(gl_FrontFacing)\n"
                             "    {\n"
                             "        gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "    }\n"
                             "    else\n"
                             "    {\n"
                             "        gl_FragColor = vec4(coreColor_b.rgb, 0.4);\n"
                             "    }\n"
                             "	\n"
                             "//	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_modelselect_vert = 
                             "/* modelselect.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* gles_modelsimple_fragment = 
                             "/* ModelSimple Fragment*/\n"
                             "precision mediump float; \n"
                             "\n"
                             "/*noperspective*/ varying  vec3 viewDirection;\n"
                             "/*noperspective*/ varying  vec3 normal;\n"
                             "\n"
                             "const vec4 ambient = vec4(0.4, 0.4, 0.4, 1.0);\n"
                             "const vec4 diffuse = vec4(0.6, 0.6, 0.6, 1.0);\n"
                             "const vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "const float specularPower = 12.0;\n"
                             "\n"
                             "const vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "const vec4 stateColors = vec4(0.8, 0.5, 0.8, 1.0);\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec4 color = stateColors;	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	float NdotL 		  = max(dot(fnormal, lightDirection), 0.0);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = reflect(-lightDirection, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	\n"
                             "	gl_FragColor = vec4(coreColor.rgb, 0.8);\n"
                             "}\n"
;
const char* gles_modelsimple_vert = 
                             "/* ModelSimple Vertex*/\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "/*noperspective*/ varying vec3 viewDirection;\n"
                             "/*noperspective*/ varying vec3 normal;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "}\n"
;
const char* gles_modelSupport_fragment = 
                             "/* modelSupport.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "flat varying vec3 gnormal;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "uniform vec4 diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "uniform float supportCos = 0.707;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform vec4 stateColors[4];\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vec4 color = stateColors[int(state)];	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec3 fgnormal		  = normalize(gnormal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	if(dot(fgnormal, vec3(0.0, 0.0, -1.0)) > supportCos)\n"
                             "		color = stateColors[3];\n"
                             "		\n"
                             "	float NdotL 		  = max(dot(fnormal, lightDirection), 0.0);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = reflect(-lightDirection, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_modelSupport_vert = 
                             "/* modelSupport.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "flat varying vec3 gnormal;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "	\n"
                             "	gnormal			= mat3(modelMatrix) * vertexNormal;\n"
                             "}\n"
;
const char* gles_modelwireframe_fragment = 
                             "/* modelwireframe.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 gnormal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying vec3 worldWater;\n"
                             "varying vec3 barycentric;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform int lightingEnable = 1;\n"
                             "uniform float transparency = 1.0;\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "uniform float error;\n"
                             "uniform float supportCos = 0.5;\n"
                             "\n"
                             "uniform int hoverState = 0;\n"
                             "uniform int waterState = 0;\n"
                             "uniform int fanzhuan = 0;\n"
                             "uniform int checkscope = 1;\n"
                             "\n"
                             "uniform float zcha = 0.01;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform float nozzle;\n"
                             "uniform vec4 stateColors[6];\n"
                             "uniform vec4 customColor;\n"
                             "\n"
                             "uniform vec3 wireframeColor = vec3(0.1);\n"
                             "uniform vec3 clearColor = vec3(0.27);\n"
                             "uniform int renderModel = 1;\n"
                             "\n"
                             "bool frontFacing()\n"
                             "{\n"
                             "        vec3 fdx = dFdx(worldPosition);\n"
                             "        vec3 fdy = dFdy(worldPosition);\n"
                             "        return dot(gnormal, cross(fdx, fdy)) > 0.0;\n"
                             "} \n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return lightingEnable * (ambient_color + diffuse_color + specular_color) + (1 - lightingEnable) * core_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(checkscope > 0 && (worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight))\n"
                             "		discard;\n"
                             "\n"
                             "	int stateInt = int(state);\n"
                             "	vec4 color;\n"
                             "	if (stateInt < 5)\n"
                             "		color = stateColors[stateInt];\n"
                             "	else\n"
                             "		color = customColor;\n"
                             "	\n"
                             "	if(error == 1.0)\n"
                             "		color = stateColors[3];	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = ambient;\n"
                             "	vec4 diffuse_color    = diffuse;\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient_color, diffuse_color, specular_color);\n"
                             "	\n"
                             "	vec3 fgnormal 		  =	normalize(gnormal);\n"
                             "	\n"
                             "	if(checkscope > 0)\n"
                             "	{\n"
                             "		if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "		if( abs(worldPosition.z - bottom) < 0.05 )\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	\n"
                             "	if(hoverState > 0)\n"
                             "	{\n"
                             "		float v = dot(fgnormal, vec3(0.0, 0.0, -1.0));\n"
                             "		if(v >= supportCos)\n"
                             "		{\n"
                             "			coreColor.r += 0.8 * v;\n"
                             "		}\n"
                             "		\n"
                             "		if(waterState == 1)\n"
                             "		{\n"
                             "			if(abs(worldPosition.z - worldWater.z) < zcha)\n"
                             "			{\n"
                             "				coreColor = vec4(0.1, 0.1, 0.1, 1.0);\n"
                             "			}\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	coreColor.rgb = coreColor.rgb + vec3(0.1, -0.1, 0.0) * nozzle;\n"
                             "\n"
                             "	if(!frontFacing())\n"
                             "	{\n"
                             "		color = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "		color.a = 1.0;\n"
                             "		vec3 fbnormal = -fnormal;\n"
                             "		vec4 ambient_color_t 	  = ambient + vec4(0.03, 0.03, 0.03, 0.0);\n"
                             "		vec4 diffuse_color_t    = diffuse;\n"
                             "		vec4 specular_color_t   = specular;\n"
                             "		coreColor = directLight(lightDir, fbnormal, color, ambient_color_t, diffuse_color_t, specular_color_t);\n"
                             "	}\n"
                             "\n"
                             "    //int fz = fanzhuan % 2;\n"
                             "    //   \n"
                             "    //if(fz == 0)\n"
                             "    //{\n"
                             "    //    if(! frontFacing())\n"
                             "    //    {\n"
                             "    //        //coreColor = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "	//		coreColor.a = 1.0;\n"
                             "    //    }\n"
                             "    //}\n"
                             "    //else\n"
                             "    //{\n"
                             "    //    if(frontFacing())\n"
                             "    //    {\n"
                             "    //        //coreColor = stateColors[5];   // vec3(0.65, 0.75, 0.95) - coreColor.rgb;\n"
                             "	//		coreColor.a = 1.0;\n"
                             "    //    }\n"
                             "    //}\n"
                             "\n"
                             "	if (renderModel != 1) {\n"
                             "		vec3 baryDelta = fwidth(barycentric);\n"
                             "			\n"
                             "		vec3 edgeFactor = smoothstep(vec3(0.0), baryDelta * 1.0, barycentric);\n"
                             "		float minEdgeFactor = min(min(edgeFactor.x, edgeFactor.y), edgeFactor.z);\n"
                             "\n"
                             "		if (renderModel == 2) {\n"
                             "			\n"
                             "			if (minEdgeFactor >= 1.0) {\n"
                             "                discard;\n"
                             "            }\n"
                             "            coreColor.rgb = mix(wireframeColor, clearColor, minEdgeFactor);\n"
                             "\n"
                             "		} else if (renderModel == 3) {\n"
                             "			coreColor.rgb = mix(wireframeColor, coreColor.rgb, minEdgeFactor);\n"
                             "		}\n"
                             "	}\n"
                             "\n"
                             "	gl_FragColor = vec4(coreColor.rgb, transparency);\n"
                             "}\n"
;
const char* gles_modelwireframe_geom = 
                             "/* modelwireframe.geom */\n"
                             "\n"
                             "layout (triangles) in;\n"
                             "layout (triangle_strip, max_vertices = 3) out;\n"
                             "\n"
                             "in vec3 viewDirectionVS[3];\n"
                             "in vec3 normalVS[3];\n"
                             "in vec3 gnormalVS[3];\n"
                             "in vec3 worldPositionVS[3];\n"
                             "in vec3 worldWaterVS[3];\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 gnormal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying vec3 worldWater;\n"
                             "varying vec3 barycentric;\n"
                             "\n"
                             "\n"
                             "void combindVertex(int index)\n"
                             "{\n"
                             "    gl_Position = gl_in[index].gl_Position;\n"
                             "\n"
                             "    viewDirection = viewDirectionVS[index];\n"
                             "    normal = normalVS[index];\n"
                             "    gnormal = gnormalVS[index];\n"
                             "    worldPosition = worldPositionVS[index];\n"
                             "    worldWater = worldWaterVS[index];\n"
                             "\n"
                             "    EmitVertex();\n"
                             "}\n"
                             "\n"
                             "\n"
                             "void main() {\n"
                             "    \n"
                             "    barycentric = vec3(1.0, 0.0, 0.0);\n"
                             "    combindVertex(0);\n"
                             "    \n"
                             "    barycentric = vec3(0.0, 1.0, 0.0);\n"
                             "    combindVertex(1);\n"
                             "\n"
                             "    barycentric = vec3(0.0, 0.0, 1.0);\n"
                             "    combindVertex(2);\n"
                             "\n"
                             "    EndPrimitive();\n"
                             "}\n"
;
const char* gles_modelwireframe_vert = 
                             "/* modelwireframe.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform vec3 water;\n"
                             "\n"
                             "varying vec3 viewDirectionVS;\n"
                             "varying vec3 normalVS;\n"
                             "varying vec3 gnormalVS;\n"
                             "varying vec3 worldPositionVS;\n"
                             "varying vec3 worldWaterVS;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirectionVS  = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normalVS          = normalMatrix * vertexNormal;\n"
                             "    gnormalVS        = mat3(modelMatrix) * vertexNormal;\n"
                             "		\n"
                             "    worldPositionVS   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "    worldWaterVS = water;\n"
                             "}\n"
;
const char* gles_moon_fragment = 
                             "/* moon.fragment */\n"
                             "\n"
                             "varying float radius;\n"
                             "\n"
                             "uniform float D = 50.0;\n"
                             "uniform vec2 hs;\n"
                             "\n"
                             "vec3 hsv2rgb(vec3 c)\n"
                             "{\n"
                             "    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n"
                             "    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n"
                             "    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n"
                             "}\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	float thick = clamp(radius - D, 0.0, 1.0);\n"
                             "	\n"
                             "	float bright= thick;\n"
                             "	vec3 v = vec3(hs, bright);\n"
                             "	\n"
                             "	gl_FragColor = vec4(hsv2rgb(v), 1.0);\n"
                             "}\n"
;
const char* gles_moon_vert = 
                             "/* moon.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying float radius;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 worldPosition = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  worldPosition;\n"
                             "	\n"
                             "	radius = length(vertexPosition);\n"
                             "}\n"
;
const char* gles_overlay_fragment = 
                             "/* overlay.fragment */\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	gl_FragColor = color;\n"
                             "}\n"
;
const char* gles_overlay_vert = 
                             "/* overlay.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   vec4 pos = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "   pos.z = -pos.w;\n"
                             "   gl_Position = pos;\n"
                             "}\n"
;
const char* gles_photo_fragment = 
                             "/* photo.fragment */\n"
                             "\n"
                             "varying float height;\n"
                             "\n"
                             "uniform float D = 0.35;\n"
                             "uniform float maxHeight = 2.2;\n"
                             "uniform vec2 hs;\n"
                             "\n"
                             "vec3 hsv2rgb(vec3 c)\n"
                             "{\n"
                             "    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n"
                             "    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n"
                             "    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n"
                             "}\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	float thick = clamp(height - D, 0.0, maxHeight) / maxHeight;\n"
                             "	vec3 v = vec3(hs, thick);\n"
                             "	\n"
                             "	gl_FragColor = vec4(hsv2rgb(v), 1.0);\n"
                             "}\n"
;
const char* gles_photo_vert = 
                             "/* photo.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying float height;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 worldPosition = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  worldPosition;\n"
                             "	\n"
                             "	height = vertexPosition.z;\n"
                             "}\n"
;
const char* gles_pickFace_fragment = 
                             "/* PickFace Fragment*/\n"
                             "precision mediump float; \n"
                             "\n"
                             "varying vec4 passColor;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	gl_FragColor = passColor;\n"
                             "}\n"
;
const char* gles_pickFace_vert = 
                             "/* PickFace Vertex*/\n"
                             "\n"
                             "attribute vec4 vertexPosition;\n"
                             "\n"
                             "varying vec4 passColor;\n"
                             "\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform ivec2 vertexBase;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	int ids[2];\n"
                             "	ids[0] = int(vertexPosition.w / 3.0) + int(vertexBase.x / 3);\n"
                             "	ids[1] = int(vertexBase.x / 3);\n"
                             "	\n"
                             "	int _faceId = ids[vertexBase.y];\n"
                             "	int i3 = _faceId / 0x1000000;\n"
                             "	_faceId = _faceId - i3 * 0x1000000;\n"
                             "	int i2 = _faceId / 0x10000;\n"
                             "	_faceId = _faceId - i2 * 0x10000;\n"
                             "	int i1 = _faceId / 0x100;\n"
                             "	_faceId = _faceId - i1 * 0x100;\n"
                             "	int i0 = _faceId;\n"
                             "	\n"
                             "	vec4 position = vec4(vertexPosition.xyz, 1.0);\n"
                             "	passColor = vec4(\n"
                             "					float(i0) / 255.0,\n"
                             "					float(i1) / 255.0,\n"
                             "					float(i2) / 255.0,\n"
                             "					float(i3) / 255.0);\n"
                             "	\n"
                             "	gl_Position = projectionMatrix * viewMatrix * modelMatrix * position;\n"
                             "}\n"
;
const char* gles_pickFaceChunk_fragment = 
                             "/* pickFaceChunk.fragment */\n"
                             "\n"
                             "varying vec4 passColor;\n"
                             "varying float flag;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	if(flag == 0.0)\n"
                             "		discard;\n"
                             "	gl_FragColor = passColor;\n"
                             "}\n"
;
const char* gles_pickFaceChunk_vert = 
                             "/* pickFaceChunk.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute float vertexFlag;\n"
                             "\n"
                             "varying vec4 passColor;\n"
                             "varying float flag;\n"
                             "\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform ivec2 vertexBase;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	int ids[2];\n"
                             "	ids[0] = int(gl_VertexID / 3.0) + int(vertexBase.x / 3);\n"
                             "	ids[1] = int(vertexBase.x / 3);\n"
                             "	\n"
                             "	int _faceId = ids[vertexBase.y];\n"
                             "	int i3 = _faceId / 0x1000000;\n"
                             "	_faceId = _faceId - i3 * 0x1000000;\n"
                             "	int i2 = _faceId / 0x10000;\n"
                             "	_faceId = _faceId - i2 * 0x10000;\n"
                             "	int i1 = _faceId / 0x100;\n"
                             "	_faceId = _faceId - i1 * 0x100;\n"
                             "	int i0 = _faceId;\n"
                             "	\n"
                             "	vec4 position = vec4(vertexPosition, 1.0);\n"
                             "	passColor = vec4(\n"
                             "					float(i0) / 255.0,\n"
                             "					float(i1) / 255.0,\n"
                             "					float(i2) / 255.0,\n"
                             "					float(i3) / 255.0);\n"
                             "					\n"
                             "	//vec4 passColors[2];\n"
                             "	//passColors[0] = vec4(1.0, 0.0, 0.0, 1.0);\n"
                             "	//passColors[1] = vec4(0.0, 1.0, 0.0, 1.0);\n"
                             "	//\n"
                             "	//int index = vertexBase.x == 120000000 ? 1 : 0;\n"
                             "	//passColor = passColors[index];\n"
                             "	\n"
                             "	gl_Position = projectionMatrix * viewMatrix * modelMatrix * position;\n"
                             "	flag			= vertexFlag;\n"
                             "}\n"
;
const char* gles_pickFaceFlag_fragment = 
                             "/* PickFaceFlag Fragment*/\n"
                             "precision mediump float; \n"
                             "\n"
                             "varying vec4 passColor;\n"
                             "varying float flag;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	if(flag == 0.0)\n"
                             "		discard;\n"
                             "	gl_FragColor = passColor;\n"
                             "}\n"
;
const char* gles_pickFaceFlag_vert = 
                             "/* PickFaceFlag Vertex*/\n"
                             "\n"
                             "attribute vec4 vertexPosition;\n"
                             "attribute float vertexFlag;\n"
                             "\n"
                             "varying vec4 passColor;\n"
                             "varying float flag;\n"
                             "\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform ivec2 vertexBase;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	int ids[2];\n"
                             "	ids[0] = int(vertexPosition.w / 3.0) + int(vertexBase.x / 3);\n"
                             "	ids[1] = int(vertexBase.x / 3);\n"
                             "	\n"
                             "	int _faceId = ids[vertexBase.y];\n"
                             "	int i3 = _faceId / 0x1000000;\n"
                             "	_faceId = _faceId - i3 * 0x1000000;\n"
                             "	int i2 = _faceId / 0x10000;\n"
                             "	_faceId = _faceId - i2 * 0x10000;\n"
                             "	int i1 = _faceId / 0x100;\n"
                             "	_faceId = _faceId - i1 * 0x100;\n"
                             "	int i0 = _faceId;\n"
                             "	\n"
                             "	vec4 position = vec4(vertexPosition.xyz, 1.0);\n"
                             "	passColor = vec4(\n"
                             "					float(i0) / 255.0,\n"
                             "					float(i1) / 255.0,\n"
                             "					float(i2) / 255.0,\n"
                             "					float(i3) / 255.0);\n"
                             "	\n"
                             "	gl_Position = projectionMatrix * viewMatrix * modelMatrix * position;\n"
                             "	flag			= vertexFlag;\n"
                             "}\n"
;
const char* gles_printerbottom_fragment = 
                             "/* printerbottom.fragment */\n"
                             "\n"
                             "varying vec2 texcoord;\n"
                             "varying vec3 normal;\n"
                             "\n"
                             "uniform vec2 imageshape;\n"
                             "uniform vec2 imagebili;\n"
                             "uniform vec2 platformsize;\n"
                             "\n"
                             "uniform sampler2D shapeTexture;\n"
                             "uniform vec4 color;\n"
                             "uniform vec4 logcolor;\n"
                             "uniform int visible;\n"
                             "uniform int colorVisible;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	vec4 coloruse = color;\n"
                             "	vec4 finalcolor = color;\n"
                             "	gl_FragColor = color;\n"
                             "\n"
                             "	if(visible == 1)\n"
                             "	{\n"
                             "		vec2 per = platformsize / imageshape;\n"
                             "		float minv = per.x < per.y ? per.x : per.y;\n"
                             "		per = per / minv;\n"
                             "	\n"
                             "		vec2 bili = per * imagebili;\n"
                             "		//vec2 bili = vec2(1.0, 1.0) * imagebili;\n"
                             "		\n"
                             "		vec2 texuse = (texcoord - vec2(0.5, 0.5)) * bili + vec2(0.5, 0.5);\n"
                             "			\n"
                             "		if(texuse.x >= 0.0 && texuse.x <= 1.0 && texuse.y >= 0.0 && texuse.y <= 1.0)\n"
                             "		{\n"
                             "			coloruse = texture2D(shapeTexture, texuse);\n"
                             "			if(coloruse.a > 0.0 && colorVisible <= 0)\n"
                             "			{\n"
                             "				coloruse = logcolor;\n"
                             "			}\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	if(coloruse.a > 0.0)\n"
                             "		finalcolor = coloruse;\n"
                             "		\n"
                             "	vec3 fgnormal 		  =	normalize(normal);\n"
                             "	if(dot(fgnormal, vec3(0.0, 0.0, -1.0)) > 0)\n"
                             "	{\n"
                             "		finalcolor.a = 0.0;\n"
                             "	}\n"
                             "	gl_FragColor = finalcolor;\n"
                             "	\n"
                             "}\n"
;
const char* gles_printerbottom_vert = 
                             "/* printerbottom.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "attribute vec2 vertexTexcoord;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec2 texcoord;\n"
                             "varying vec3 normal;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "   texcoord = vertexTexcoord;\n"
                             "   \n"
                             "   mat3 normalMatrix = mat3(viewMatrix);\n"
                             "   normal          = normalMatrix * vertexNormal;\n"
                             "}\n"
;
const char* gles_printergrid_fragment = 
                             "/* printergrid.fragment */\n"
                             "precision mediump float;\n"
                             "varying vec2 flag;\n"
                             "uniform float visible;\n"
                             "uniform vec4 xshowcolor;\n"
                             "uniform vec4 yshowcolor;\n"
                             "uniform vec4 linecolor;\n"
                             "uniform vec4 xyIndexcolor;\n"
                             "uniform float highlight_index_x;\n"
                             "uniform float highlight_index_y;\n"
                             "void main() \n"
                             "{\n"
                             "	if(int(flag.x) == 0)\n"
                             "	{\n"
                             "		gl_FragColor = yshowcolor;\n"
                             "	}\n"
                             "	else if(int(flag.y) == 0)\n"
                             "	{\n"
                             "		gl_FragColor = xshowcolor;\n"
                             "	}\n"
                             "	else\n"
                             "	{\n"
                             "		//if((((int(flag.x/10.0))%4 > 0) || ((int(flag.y/10.0))%4 > 0)) && (visible == 0.0))\n"
                             "		//	discard;\n"
                             "		if(int(highlight_index_x) == int(flag.x) || int(highlight_index_y) == int(flag.y))\n"
                             "		{\n"
                             "			gl_FragColor = xyIndexcolor; // vec4(1.0, 1.0, 0.0,1.0);\n"
                             "		}\n"
                             "		else\n"
                             "		{\n"
                             "			gl_FragColor = linecolor;\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "\n"
                             "/*\n"
                             "	if (visible == 0.0)\n"
                             "	{\n"
                             "		discard;\n"
                             "	}\n"
                             "	else\n"
                             "	{\n"
                             "		if(((int(flag.x/10.0))%4 > 0) || ((int(flag.y/10.0))%4 > 0))\n"
                             "			//fragColor = showcolor;\n"
                             "			discard;\n"
                             "		else	\n"
                             "			fragColor = linecolor;\n"
                             "	}\n"
                             "	*/\n"
                             "}\n"
;
const char* gles_printergrid_vert = 
                             "/* printergrid.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec2 vertexFlag;\n"
                             "uniform mat4 modelViewProjection;\n"
                             "\n"
                             "varying vec2 flag;\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "   flag = vertexFlag;\n"
                             "}\n"
;
const char* gles_pure_fragment = 
                             "/* pure.fragment */\n"
                             "precision mediump float;\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	gl_FragColor = color;\n"
                             "}\n"
;
const char* gles_pure_vert = 
                             "/* pure.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "}\n"
;
const char* gles_rendertoframebuffer_fragment = 
                             "#version 150 core\n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	fragColor = vec4(1.0);\n"
                             "}\n"
;
const char* gles_rendertoframebuffer_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "uniform vec4 layoutRect;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	vec2 project = (vertexPosition.xy - layoutRect.xy) / layoutRect.zw * 2.0 - 1.0;\n"
                             "	gl_Position = vec4(project.x, -project.y, 0.0, 1.0);\n"
                             "}\n"
;
const char* gles_slicepreview_fragment = 
                             "/* slicepreview.fragment */\n"
                             "\n"
                             "varying vec3 normal;\n"
                             "varying vec2 flag;\n"
                             "varying vec4 drawFlag;\n"
                             "varying vec4 smoothFlag;\n"
                             "varying vec3 viewDirection;\n"
                             "\n"
                             "uniform vec4 color = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "\n"
                             "uniform vec4 front_ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 front_diffuse = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 specular = vec4(0.2, 0.2, 0.2, 1.0);\n"
                             "\n"
                             "uniform vec3 light_direction1 = vec3(1.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform int showType = 0;\n"
                             "uniform int animation = 0;\n"
                             "\n"
                             "uniform vec4 clipValue;\n"
                             "uniform vec2 layershow;\n"
                             "uniform int layerstartflag_show;\n"
                             "\n"
                             "uniform vec4 typecolors[18];\n"
                             "uniform vec4 speedcolors[13];\n"
                             "uniform vec4 nozzlecolors[6];\n"
                             "\n"
                             "uniform int typecolorsshow[18];\n"
                             "\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 diffuse_color, vec4 core_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	diffuse_color         = diffuse_color * core_color;\n"
                             "	vec4 total_diffuse    = NdotL * diffuse_color;\n"
                             "	\n"
                             "//	/*\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower) * core_color;\n"
                             "//	*/\n"
                             "	\n"
                             "	return total_diffuse + specularColor;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(flag.x < clipValue.x || flag.x > clipValue.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x == clipValue.y && (flag.y < clipValue.z || flag.y > clipValue.w))\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x < layershow.x || flag.x > layershow.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(typecolorsshow[int(drawFlag.y)] == 0)\n"
                             "		discard;\n"
                             "	\n"
                             "	vec4 core_color = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "	vec3 lightDir = normalize(light_direction1);\n"
                             "	\n"
                             "	if(showType == 0)\n"
                             "	{\n"
                             "		int stype = int(drawFlag.x);\n"
                             "		core_color = speedcolors[stype];\n"
                             "	}\n"
                             "	else if(showType == 1)\n"
                             "		core_color = typecolors[int(drawFlag.y)];\n"
                             "	else if(showType == 2)\n"
                             "		core_color = nozzlecolors[int(drawFlag.z)];\n"
                             "		\n"
                             "	if(layerstartflag_show == 1 && smoothFlag.x > 0.0 && smoothFlag.x <= 0.2)\n"
                             "		core_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = front_ambient;\n"
                             "	vec4 diffuse_color    = front_diffuse;\n"
                             "	\n"
                             "	ambient_color 		  = ambient_color * core_color;\n"
                             "	\n"
                             "	vec4 light_color1     = directLight(lightDir, fnormal, diffuse_color, core_color);\n"
                             "	\n"
                             "	core_color = ambient_color + light_color1;\n"
                             "	core_color.a = color.a;\n"
                             "	\n"
                             "	if(animation > 0)\n"
                             "	{\n"
                             "		if(flag.x == clipValue.y)\n"
                             "		{\n"
                             "			core_color += vec4(0.3, 0.3, 0.3, 0.0);\n"
                             "		}\n"
                             "		else\n"
                             "		{\n"
                             "			core_color -= vec4(0.3, 0.3, 0.3, 0.0);\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	gl_FragColor = core_color;\n"
                             "}\n"
;
const char* gles_slicepreview_vert = 
                             "/* slicepreview.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "attribute vec2 vertexFlag;\n"
                             "attribute vec4 vertexDrawFlag;\n"
                             "attribute vec4 vertexSmoothFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 normal;\n"
                             "varying vec2 flag;\n"
                             "varying vec4 drawFlag;\n"
                             "varying vec4 smoothFlag;\n"
                             "varying vec3 viewDirection;\n"
                             "\n"
                             "void main( void )\n"
                             "{	\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 world_position = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  world_position;\n"
                             "	flag = vertexFlag;\n"
                             "	drawFlag = vertexDrawFlag;\n"
                             "	smoothFlag = vertexSmoothFlag;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-world_position));\n"
                             "    normal          = mat3(modelview_matrix) * vertexNormal;\n"
                             "}\n"
;
const char* gles_slicepreviewAD_fragment = 
                             "/* slicepreviewAD.fragment */\n"
                             "\n"
                             "varying vec3 normal;\n"
                             "varying vec2 flag;\n"
                             "varying vec4 drawFlag;\n"
                             "varying vec3 viewDirection;\n"
                             "\n"
                             "uniform vec4 color = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "\n"
                             "uniform vec4 front_ambient = vec4(0.7, 0.7, 0.7, 1.0);\n"
                             "uniform vec4 front_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "\n"
                             "uniform vec3 light_direction1 = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform int showType = 0;\n"
                             "uniform int animation = 0;\n"
                             "uniform int retractionShow = 0;\n"
                             "\n"
                             "uniform vec4 clipValue;\n"
                             "uniform vec2 layershow;\n"
                             "\n"
                             "uniform vec4 typecolors[16];\n"
                             "uniform vec4 speedcolors[13];\n"
                             "uniform vec4 nozzlecolors[9];\n"
                             "\n"
                             "uniform int typecolorsshow[15];\n"
                             "\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 diffuse_color, vec4 core_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	diffuse_color         = diffuse_color * core_color;\n"
                             "	vec4 total_diffuse    = NdotL * diffuse_color;\n"
                             "	\n"
                             "//	/*\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "//	*/\n"
                             "	\n"
                             "	return total_diffuse + specularColor;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(flag.x < clipValue.x || flag.x > clipValue.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x == clipValue.y && (flag.y < clipValue.z || flag.y > clipValue.w))\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x < layershow.x || flag.x > layershow.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(typecolorsshow[int(drawFlag.y)] == 0)\n"
                             "		discard;\n"
                             "	\n"
                             "	vec4 core_color = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "	\n"
                             "	if(showType == 0)\n"
                             "	{\n"
                             "		core_color = typecolors[int(drawFlag.y)];\n"
                             "		if(retractionShow == 1)\n"
                             "		{\n"
                             "			if(int(drawFlag.y) == 13 || int(drawFlag.y) == 14)//travel and react\n"
                             "				core_color = typecolors[15];	\n"
                             "		}\n"
                             "	}\n"
                             "	else if(showType == 1)\n"
                             "	{\n"
                             "		core_color = nozzlecolors[int(drawFlag.z)];\n"
                             "		if(retractionShow == 1)\n"
                             "		{\n"
                             "			if(int(drawFlag.z) == 6 || int(drawFlag.z) == 7)//travel and react\n"
                             "				core_color = nozzlecolors[8];	\n"
                             "		}\n"
                             "	}\n"
                             "	else if(showType == 2)\n"
                             "	{\n"
                             "		int stype = int(drawFlag.x);\n"
                             "		core_color = speedcolors[stype];\n"
                             "	}\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = front_ambient;\n"
                             "	vec4 diffuse_color    = front_diffuse;\n"
                             "	\n"
                             "	ambient_color 		  = ambient_color * core_color;\n"
                             "	\n"
                             "	vec4 light_color1     = directLight(light_direction1, fnormal, diffuse_color, core_color);\n"
                             "	\n"
                             "	core_color = ambient_color + light_color1;\n"
                             "	core_color.a = color.a;\n"
                             "	\n"
                             "	if(animation > 0)\n"
                             "	{\n"
                             "		if(flag.x == clipValue.y)\n"
                             "		{\n"
                             "			core_color += vec4(0.3, 0.3, 0.3, 0.0);\n"
                             "		}\n"
                             "		else\n"
                             "		{\n"
                             "			core_color -= vec4(0.3, 0.3, 0.3, 0.0);\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	gl_FragColor = core_color;\n"
                             "}\n"
;
const char* gles_slicepreviewAD_vert = 
                             "/* slicepreviewAD.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "attribute vec2 vertexFlag;\n"
                             "attribute vec4 vertexDrawFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 normal;\n"
                             "varying vec2 flag;\n"
                             "varying vec4 drawFlag;\n"
                             "varying vec3 viewDirection;\n"
                             "\n"
                             "void main( void )\n"
                             "{	\n"
                             "	flag = vertexFlag;\n"
                             "	drawFlag = vertexDrawFlag;\n"
                             "\n"
                             "	mat4 usematrix = modelMatrix;\n"
                             "\n"
                             "	if((int(drawFlag.z) == 1 ||int(drawFlag.z) == 7) && int(drawFlag.w) == 1)\n"
                             "	{\n"
                             "		mat4 translate = mat4(\n"
                             "			1.0, 0.0, 0.0, 0.0,\n"
                             "			0.0, 1.0, 0.0, 0.0,\n"
                             "			0.0, 0.0, 1.0, 0.0,\n"
                             "			-35.0, 0.0, 0.0, 1.0\n"
                             "		);\n"
                             "		usematrix = modelMatrix * translate;\n"
                             "	}\n"
                             "	mat4 modelview_matrix = viewMatrix * usematrix;\n"
                             "	vec4 world_position = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  world_position;\n"
                             "	\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-world_position));\n"
                             "    normal          = mat3(modelview_matrix) * vertexNormal;\n"
                             "}\n"
;
const char* gles_slicepreviewpath_fragment = 
                             "/* slicepreviewpath.fragment */\n"
                             "\n"
                             "varying vec2 flag;\n"
                             "uniform vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 clipValue;\n"
                             "uniform vec2 layershow;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(flag.x < clipValue.x || flag.x > clipValue.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x == clipValue.y && (flag.y < clipValue.z || flag.y > clipValue.w))\n"
                             "		discard;\n"
                             "		\n"
                             "	if(flag.x < layershow.x || flag.x > layershow.y)\n"
                             "		discard;\n"
                             "	\n"
                             "	vec4 core_color = color;\n"
                             "	gl_FragColor = core_color;\n"
                             "}\n"
;
const char* gles_slicepreviewpath_vert = 
                             "/* slicepreviewpath.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec2 vertexFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec2 flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{	\n"
                             "	mat4 modelview_matrix = viewMatrix * modelMatrix;\n"
                             "	vec4 world_position = modelview_matrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  world_position;\n"
                             "	flag = vertexFlag;\n"
                             "}\n"
;
const char* gles_splitplane_fragment = 
                             "/* splitplane.fragment */\n"
                             "\n"
                             "varying vec3 worldPosition;\n"
                             "uniform vec4 color;\n"
                             "uniform vec3 clip[2];\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	if(worldPosition.z < clip[0].z || worldPosition.z > clip[1].z\n"
                             "		|| worldPosition.x < clip[0].x || worldPosition.x > clip[1].x\n"
                             "		|| worldPosition.y < clip[0].y || worldPosition.y > clip[1].y)\n"
                             "		discard;\n"
                             "		\n"
                             "	gl_FragColor = color;\n"
                             "}\n"
;
const char* gles_splitplane_vert = 
                             "/* splitplane.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* gles_support_fragment = 
                             "/* Support Fragment*/\n"
                             "\n"
                             "precision mediump float;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying float flag;\n"
                             "\n"
                             "uniform vec4 ambient; // = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "uniform vec4 diffuse; // = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 specular; // = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "const float specularPower = 12.0;\n"
                             "\n"
                             "const vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 stateColors[6];\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    vec4 color = stateColors[int(flag)];\n"
                             "\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	float NdotL 		  = dot(fnormal, lightDirection);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - lightDirection);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	\n"
                             "    gl_FragColor = vec4(coreColor.rgb, color.a);\n"
                             "}\n"
                             "\n"
;
const char* gles_support_vert = 
                             "/* Support Vertex*/\n"
                             "precision mediump float;\n"
                             "\n"
                             "attribute vec4 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "attribute float vertexFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying float flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition.xyz, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition.xyz, 1.0));\n"
                             "	flag			= vertexFlag;\n"
                             "	\n"
                             "	if(vertexFlag == 0.0)\n"
                             "	{\n"
                             "		gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "	}\n"
                             "}\n"
;
const char* gles_supportpos_fragment = 
                             "/* supportpos.fragment */\n"
                             "\n"
                             "noperspective varying vec3 viewDirection;\n"
                             "noperspective varying vec3 normal;\n"
                             "noperspective varying vec3 worldPosition;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.4, 0.4, 0.4, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.6, 0.6, 0.6, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 stateColors = vec4(0.8, 0.5, 0.8, 1.0);\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight)\n"
                             "		discard;\n"
                             "		\n"
                             "	vec4 color = stateColors;	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	float NdotL 		  = max(dot(fnormal, lightDirection), 0.0);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = reflect(-lightDirection, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "\n"
                             "	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_supportpos_vert = 
                             "/* supportpos.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "noperspective varying vec3 viewDirection;\n"
                             "noperspective varying vec3 normal;\n"
                             "noperspective varying vec3 worldPosition;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "}\n"
;
const char* gles_supportshow_fragment = 
                             "/* supportshow.fragment */\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying float flag;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "uniform vec4 diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 stateColors[6];\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    vec4 color = stateColors[int(flag)];\n"
                             "//    color.a = flag;\n"
                             "\n"
                             "	if(worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight)\n"
                             "		discard;\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	float NdotL 		  = dot(fnormal, lightDirection);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - lightDirection);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	\n"
                             "//        if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "//	{\n"
                             "//		coreColor.g += 0.4;\n"
                             "//	}\n"
                             "	\n"
                             "//        if( abs(worldPosition.z - bottom) < 0.01 )\n"
                             "//        {\n"
                             "//                coreColor.g += 0.4;\n"
                             "//        }\n"
                             "	\n"
                             "        gl_FragColor = vec4(coreColor.rgb, color.a);\n"
                             "}\n"
                             "\n"
;
const char* gles_supportshow_vert = 
                             "/* supportshow.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "attribute float vertexFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying float flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "	flag			= vertexFlag;\n"
                             "	\n"
                             "	if(vertexFlag == 0.0)\n"
                             "	{\n"
                             "		gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "	}\n"
                             "}\n"
;
const char* gles_tex_fragment = 
                             "/* tex.fragment */\n"
                             "\n"
                             "uniform sampler2D shapeTexture;\n"
                             "\n"
                             "varying vec2 texcoord;\n"
                             "void main() \n"
                             "{\n"
                             "	vec4 color = texture2D(shapeTexture, texcoord);\n"
                             "	if(color.w == 1.0) discard;\n"
                             "	gl_FragColor = vec4(color.xyz, 1.0);  \n"
                             "}\n"
;
const char* gles_tex_vert = 
                             "/* tex.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec2 vertexTexcoord;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "varying vec2 texcoord;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "   texcoord = vertexTexcoord;\n"
                             "}\n"
;
const char* gles_texshape_fragment = 
                             "/* texshape.fragment */\n"
                             "\n"
                             "uniform sampler2D shapeTexture;\n"
                             "\n"
                             "varying vec2 texcoord;\n"
                             "void main() \n"
                             "{\n"
                             "	vec4 color = texture2D(shapeTexture, texcoord);\n"
                             "	if(color.a == 0.0)\n"
                             "	{\n"
                             "		color = vec4(0.44, 0.44, 0.44, 1.0);\n"
                             "	}\n"
                             "	gl_FragColor = vec4(color.rgb, 1.0);  \n"
                             "}\n"
;
const char* gles_texshape_vert = 
                             "/* texshape.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec2 vertexTexcoord;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "varying vec2 texcoord;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "   texcoord = vertexTexcoord;\n"
                             "}\n"
;
const char* gles_text_fragment = 
                             "/* text.fragment */ \n"
                             "\n"
                             "uniform vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	gl_FragColor = color;\n"
                             "}\n"
;
const char* gles_text_vert = 
                             "/* text.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "}\n"
;
const char* gles_xyzIndicator_fragment = 
                             "/* xyzIndicator.fragment */\n"
                             "precision mediump float;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "const vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "const vec4 diffuse = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "const vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "const float specularPower = 12.0;\n"
                             "const vec3 lightDirection = vec3(1.0, 0.0, 0.0);\n"
                             "\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "		\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "	\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient, diffuse, specular);	\n"
                             "	\n"
                             "	gl_FragColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* gles_xyzIndicator_vert = 
                             "/* xyzIndicator.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "attribute vec3 vertexNormal;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "varying vec3 viewDirection;\n"
                             "varying vec3 normal;\n"
                             "varying vec3 worldPosition;\n"
                             "varying vec3  worldWater;\n"
                             "\n"
                             "void main( void ) \n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition.xyz, 1.0);\n"
                             "	gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "	normal          = normalMatrix * vertexNormal;\n"
                             "	\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition.xyz, 1.0));\n"
                             "	\n"
                             "}\n"
;
const char* gles_zproject_fragment = 
                             "/* zproject.fragment */\n"
                             "\n"
                             "uniform int cameraDir;\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(cameraDir == 0)\n"
                             "		discard;\n"
                             "		\n"
                             "	gl_FragColor = vec4(0.1451, 0.1569, 0.1647, 1.0);\n"
                             "}\n"
;
const char* gles_zproject_vert = 
                             "/* zproject.vert */\n"
                             "\n"
                             "attribute vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform float projectZ;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    vec4 tworldPosition = modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "	tworldPosition.z = projectZ;\n"
                             "    gl_Position = projectionMatrix * viewMatrix *  tworldPosition;\n"
                             "}\n"
;
//-----------gles code array.
const char* gles_shader_code_array[83] = {
	gles_admodel_fragment,
	gles_admodel_vert,
	gles_blur_fragment,
	gles_blur_vert,
	gles_bottomface_fragment,
	gles_bottomface_vert,
	gles_boxclippure_fragment,
	gles_boxclippure_vert,
	gles_chunk_fragment,
	gles_chunk_vert,
	gles_color_fragment,
	gles_color_vert,
	gles_dlpsupportindicator_fragment,
	gles_dlpsupportindicator_vert,
	gles_finephong_fragment,
	gles_finephong_vert,
	gles_finephongtex_fragment,
	gles_finephongtex_vert,
	gles_glcomp1_fragment,
	gles_glcomp1_vert,
	gles_gpuantialiasing_fragment,
	gles_gpuantialiasing_vert,
	gles_manipulate_fragment,
	gles_manipulate_vert,
	gles_model_fragment,
	gles_model_vert,
	gles_modeldlp_fragment,
	gles_modeldlp_vert,
	gles_modelline_fragment,
	gles_modelline_vert,
	gles_modelselect_fragment,
	gles_modelselect_vert,
	gles_modelsimple_fragment,
	gles_modelsimple_vert,
	gles_modelSupport_fragment,
	gles_modelSupport_vert,
	gles_modelwireframe_fragment,
	gles_modelwireframe_geom,
	gles_modelwireframe_vert,
	gles_moon_fragment,
	gles_moon_vert,
	gles_overlay_fragment,
	gles_overlay_vert,
	gles_photo_fragment,
	gles_photo_vert,
	gles_pickFace_fragment,
	gles_pickFace_vert,
	gles_pickFaceChunk_fragment,
	gles_pickFaceChunk_vert,
	gles_pickFaceFlag_fragment,
	gles_pickFaceFlag_vert,
	gles_printerbottom_fragment,
	gles_printerbottom_vert,
	gles_printergrid_fragment,
	gles_printergrid_vert,
	gles_pure_fragment,
	gles_pure_vert,
	gles_rendertoframebuffer_fragment,
	gles_rendertoframebuffer_vert,
	gles_slicepreview_fragment,
	gles_slicepreview_vert,
	gles_slicepreviewAD_fragment,
	gles_slicepreviewAD_vert,
	gles_slicepreviewpath_fragment,
	gles_slicepreviewpath_vert,
	gles_splitplane_fragment,
	gles_splitplane_vert,
	gles_support_fragment,
	gles_support_vert,
	gles_supportpos_fragment,
	gles_supportpos_vert,
	gles_supportshow_fragment,
	gles_supportshow_vert,
	gles_tex_fragment,
	gles_tex_vert,
	gles_texshape_fragment,
	gles_texshape_vert,
	gles_text_fragment,
	gles_text_vert,
	gles_xyzIndicator_fragment,
	gles_xyzIndicator_vert,
	gles_zproject_fragment,
	gles_zproject_vert
};
//------------ gl3.0 code
const char* antialiasing_fragment = 
                             "#version 330 core\n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "in vec2 texCoord;\n"
                             "\n"
                             "uniform vec2 textureSize;\n"
                             "uniform sampler2D screenTexture;\n"
                             "uniform int antiflag = 1;\n"
                             "\n"
                             "vec4 AntiAlias_None(vec2 uv, vec2 texsize, sampler2D theTexture) \n"
                             "{\n"
                             "    return texture2D(theTexture, uv / texsize, -99999.0);\n"
                             "}\n"
                             "\n"
;
const char* antialiasing_vert = 
                             "#version 330 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec2 vertexTexCoord;\n"
                             "\n"
                             "out vec2 texCoord;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   //gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "   gl_Position = vec4(vertexPosition, 1.0);\n"
                             "   texCoord = vertexTexCoord;\n"
                             "}\n"
;
const char* blur_fragment = 
                             "#version 150 core\n"
                             "in vec2 texCoord0;\n"
                             "uniform int ssa; \n"
                             "uniform int need_thres; \n"
                             "uniform vec2 img_size; \n"
                             "uniform vec2 clrThreshold;\n"
                             "\n"
                             "uniform sampler2D samplerTexture0;\n"
                             "uniform sampler2D samplerTexture1;\n"
                             "uniform sampler2D samplerTexture2;\n"
                             "uniform sampler2D samplerTexture3;\n"
                             "uniform sampler2D samplerTexture4;\n"
                             "uniform sampler2D samplerTexture5;\n"
                             "uniform sampler2D samplerTexture6;\n"
                             "uniform sampler2D samplerTexture7;\n"
                             "\n"
                             "\n"
                             "out vec4 fragData0;\n"
                             "out vec4 fragData1;\n"
                             "out vec4 fragData2;\n"
                             "out vec4 fragData3;\n"
                             "out vec4 fragData4;\n"
                             "out vec4 fragData5;\n"
                             "out vec4 fragData6;\n"
                             "out vec4 fragData7;\n"
                             "\n"
                             "\n"
                             "vec4 blur(sampler2D postTexture, int lpos, int rpos, float bili)\n"
                             "{\n"
                             "	vec4 retOutput = vec4(0.0, 0.0, 0.0, 0.0);\n"
                             "	vec4 clrtemp = vec4(0.0, 0.0, 0.0, 0.0); \n"
                             "	for(int i = -lpos; i <= rpos; i++) \n"
                             "	{ \n"
                             "		for(int j = -lpos; j <= rpos; j++) \n"
                             "		{ \n"
                             "			vec2 offset = vec2(float(i)/img_size.x, float(j)/img_size.y); \n"
                             "			vec4 temp = texture(postTexture, texCoord0+offset) / bili; \n"
                             "			clrtemp += temp; \n"
                             "		} \n"
                             "	} \n"
                             "	clrtemp.a = 1.0;  \n"
                             "	if(need_thres > 0) { \n"
                             "		vec2 thresholdvalue = vec2(clrThreshold.x, clrThreshold.y);\n"
                             "		float rangratio = thresholdvalue.y-thresholdvalue.x;\n"
                             "		if(clrtemp.r >= 0.003 && clrtemp.r <= 0.997)\n"
                             "			retOutput = vec4(thresholdvalue.x + clrtemp.r * rangratio, 0.0, 0.0, 1.0);\n"
                             "			//retOutput = texture(postTexture, texCoord0);\n"
                             "		else \n"
                             "			retOutput = clrtemp; \n"
                             "	} \n"
                             "	else if(need_thres == 0) { \n"
                             "		retOutput = clrtemp;  \n"
                             "	} \n"
                             "	else { \n"
                             "		clrtemp = texture(postTexture, texCoord0); \n"
                             "		clrtemp.a = 1.0; \n"
                             "		retOutput = clrtemp;  \n"
                             "	} \n"
                             "	\n"
                             "	return retOutput;\n"
                             "}\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	float bbili = float(ssa * ssa); \n"
                             "	int llpos = ssa/2; \n"
                             "	int rrpos = (ssa-1)/2; \n"
                             "	\n"
                             "	fragData0 = blur(samplerTexture0, llpos, rrpos, bbili);\n"
                             "	fragData1 = blur(samplerTexture1, llpos, rrpos, bbili);\n"
                             "	fragData2 = blur(samplerTexture2, llpos, rrpos, bbili);\n"
                             "	fragData3 = blur(samplerTexture3, llpos, rrpos, bbili);\n"
                             "	fragData4 = blur(samplerTexture4, llpos, rrpos, bbili);\n"
                             "	fragData5 = blur(samplerTexture5, llpos, rrpos, bbili);\n"
                             "	fragData6 = blur(samplerTexture6, llpos, rrpos, bbili);\n"
                             "	fragData7 = blur(samplerTexture7, llpos, rrpos, bbili);\n"
                             "\n"
                             "}\n"
;
const char* blur_vert = 
                             "#version 150 core\n"
                             "in vec3 vertexPosition;\n"
                             "in vec2 vertexTexCoord;\n"
                             "out vec2 texCoord0;\n"
                             "void main()\n"
                             "{\n"
                             "   gl_Position = vec4(vertexPosition, 1.0);\n"
                             "	texCoord0 = vertexTexCoord;\n"
                             "}\n"
;
const char* color_fragment = 
                             "#version 150 core \n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "in vec4 fcolor;\n"
                             "void main() \n"
                             "{\n"
                             "	fragColor = fcolor;\n"
                             "}\n"
;
const char* color_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec4 vertexColor;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "out vec4 fcolor;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "   fcolor = vertexColor;\n"
                             "}\n"
;
const char* gcodepreviewG_fragment = 
                             "#version 150 core\n"
                             "out vec4 fragment_color;\n"
                             "\n"
                             "in vec3 normal;\n"
                             "flat in vec2 step;\n"
                             "flat in float visualType;\n"
                             "in vec3 viewDirection;\n"
                             "\n"
                             "// uniform vec4 color = vec4(0.8, 0.8, 0.8, 1.0); \n"
                             "uniform vec4 darkColor = vec4(0.161, 0.161, 0.161, 1.0);\n"
                             "\n"
                             "uniform vec3 light_direction = vec3(0.0, 0.0, 1.0);\n"
                             "uniform vec4 front_ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 front_diffuse = vec4(0.6, 0.6, 0.6, 1.0);\n"
                             "uniform vec4 back_ambient = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 back_diffuse = vec4(0.3, 0.3, 0.3, 1.0);\n"
                             "uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "\n"
                             "uniform int showType = 0;\n"
                             "uniform int animation = 0;\n"
                             "\n"
                             "uniform vec4 clipValue;\n"
                             "uniform vec2 layershow;\n"
                             "\n"
                             "uniform float speedcolorSize;\n"
                             "uniform vec4 typecolors[18];\n"
                             "uniform vec4 speedcolors[13];\n"
                             "uniform vec4 nozzlecolors[6];\n"
                             "uniform int typecolorsshow[18];\n"
                             "\n"
                             "uniform float specularPower = 32.0;\n"
                             "\n"
                             "vec4 directLight(vec4 core_color)\n"
                             "{\n"
                             "	vec4 ambient_color 	  = front_ambient * core_color;	\n"
                             "	vec4 diffuse_color    = front_diffuse;\n"
                             "	vec3 light_dir = normalize(light_direction);\n"
                             "	vec3 fnormal          =	normalize(normal); \n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	diffuse_color         = diffuse_color * core_color;\n"
                             "	vec4 total_diffuse    = NdotL * diffuse_color;\n"
                             "	\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	vec4 resultColor = total_diffuse + ambient_color;\n"
                             "	resultColor.a = 1.0;\n"
                             "	return resultColor;\n"
                             "}\n"
                             "\n"
                             "vec4 typeColor()\n"
                             "{\n"
                             "	return typecolors[int(visualType)];\n"
                             "}\n"
                             "\n"
                             "vec4 nozzleColor()\n"
                             "{\n"
                             "	return nozzlecolors[int(visualType)];\n"
                             "}\n"
                             "\n"
                             "vec4 speedColor()\n"
                             "{\n"
                             "	float speedFlag = visualType * speedcolorSize;\n"
                             "	int stype = int(speedFlag);\n"
                             "	vec4 lastColor = speedcolors[stype];\n"
                             "	vec4 nextColor = speedcolors[stype + 1];\n"
                             "	return lastColor + (nextColor - lastColor) * (speedFlag - float(stype));\n"
                             "}\n"
                             "\n"
                             "vec4 heightColor()\n"
                             "{\n"
                             "	return speedColor();\n"
                             "}\n"
                             "\n"
                             "vec4 lineWidthColor()\n"
                             "{\n"
                             "	return speedColor();\n"
                             "}\n"
                             "\n"
                             "vec4 flowColor()\n"
                             "{\n"
                             "	return speedColor();\n"
                             "}\n"
                             "\n"
                             "vec4 layerTimeColor()\n"
                             "{\n"
                             "	return speedColor();\n"
                             "}\n"
                             "\n"
                             "vec4 fanSpeedColor()\n"
                             "{\n"
                             "	return speedColor();\n"
                             "}\n"
                             "\n"
                             "vec4 temperatureColor()\n"
                             "{\n"
                             "	return speedColor();\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(step.x > clipValue.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if((step.x == clipValue.y) && (step.y > clipValue.w))\n"
                             "		discard;\n"
                             "		\n"
                             "	if(step.x < layershow.x || step.x > layershow.y)\n"
                             "		discard;\n"
                             "	\n"
                             "	if(visualType < 0.0)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(showType == 1 && typecolorsshow[int(visualType)] == 0)\n"
                             "		discard;\n"
                             "	\n"
                             "	vec4 colors[9];\n"
                             "	colors[0] = speedColor();\n"
                             "	colors[1] = typeColor();\n"
                             "	colors[2] = nozzleColor();\n"
                             "	colors[3] = heightColor();\n"
                             "	colors[4] = lineWidthColor();\n"
                             "	colors[5] = flowColor();\n"
                             "	colors[6] = layerTimeColor();\n"
                             "	colors[7] = fanSpeedColor();\n"
                             "	colors[8] = temperatureColor();\n"
                             "\n"
                             "	vec4 core_color = colors[showType];\n"
                             "\n"
                             "	if (animation == 1 && step.x != clipValue.y) {\n"
                             "		core_color = darkColor;\n"
                             "	}\n"
                             "\n"
                             "	vec4 resultColor     = directLight(core_color);\n"
                             "	\n"
                             "	fragment_color = resultColor;\n"
                             "}\n"
;
const char* gcodepreviewG_geom = 
                             "#version 150 core\n"
                             "\n"
                             "layout (points) in;\n"
                             "layout (triangle_strip, max_vertices = 10) out;\n"
                             "\n"
                             "in vec3 startVertexVS[1];\n"
                             "in vec3 endVertexVS[1];\n"
                             "in vec3 vNormalVS[1];\n"
                             "flat in vec2 stepVS[1];\n"
                             "flat in float visualTypeVS[1];\n"
                             "flat in float lineWidthPerStep[1];\n"
                             "\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform mat4 modelMatrix;\n"
                             "\n"
                             "out vec3 normal;\n"
                             "flat out vec2 step;\n"
                             "flat out float visualType;\n"
                             "out vec3 viewDirection;\n"
                             "\n"
                             "uniform float layerHeight = 0.1;\n"
                             "//uniform float lineWidth = 0.4;\n"
                             "\n"
                             "void combindVertex(vec3 pos, vec3 norm)\n"
                             "{\n"
                             "	vec4 world_position = viewMatrix * modelMatrix * vec4(pos, 1.0);\n"
                             "	gl_Position = projectionMatrix *  world_position;\n"
                             "	normal = mat3(viewMatrix) * norm;\n"
                             "	viewDirection  = normalize(vec3(world_position));\n"
                             "	EmitVertex();\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{	\n"
                             "	step = stepVS[0];\n"
                             "	visualType = visualTypeVS[0];\n"
                             "\n"
                             "	vec3 norms[8];\n"
                             "	norms[0] = vec3(0.0, 0.0, 1.0);\n"
                             "	norms[1] = vNormalVS[0];\n"
                             "	norms[2] = vec3(0.0, 0.0, -1.0);\n"
                             "	norms[3] = - vNormalVS[0];\n"
                             "	norms[4] = vec3(0.0, 0.0, 1.0);\n"
                             "	norms[5] = vNormalVS[0];\n"
                             "	norms[6] = vec3(0.0, 0.0, -1.0);\n"
                             "	norms[7] = - vNormalVS[0];\n"
                             "	\n"
                             "	vec3 poses[8];\n"
                             "	// poses[0] = startVertexVS[0] + 0.05 * norms[0];\n"
                             "	// poses[1] = startVertexVS[0] + 0.2  * norms[1];\n"
                             "	// poses[2] = startVertexVS[0] + 0.05 * norms[2];\n"
                             "	// poses[3] = startVertexVS[0] + 0.2  * norms[3];\n"
                             "	// poses[4] = endVertexVS[0]   + 0.05 * norms[4];\n"
                             "	// poses[5] = endVertexVS[0]   + 0.2  * norms[5];\n"
                             "	// poses[6] = endVertexVS[0]   + 0.05 * norms[6];\n"
                             "	// poses[7] = endVertexVS[0]   + 0.2  * norms[7];\n"
                             "\n"
                             " 	float lineWidth = lineWidthPerStep[0];\n"
                             "	poses[0] = startVertexVS[0] + layerHeight * 0.5 * norms[0];\n"
                             "	poses[1] = startVertexVS[0] + lineWidth   * 0.5 * norms[1];\n"
                             "	poses[2] = startVertexVS[0] + layerHeight * 0.5 * norms[2];\n"
                             "	poses[3] = startVertexVS[0] + lineWidth   * 0.5 * norms[3];\n"
                             "	poses[4] = endVertexVS[0]   + layerHeight * 0.5 * norms[4];\n"
                             "	poses[5] = endVertexVS[0]   + lineWidth   * 0.5 * norms[5];\n"
                             "	poses[6] = endVertexVS[0]   + layerHeight * 0.5 * norms[6];\n"
                             "	poses[7] = endVertexVS[0]   + lineWidth   * 0.5 * norms[7];\n"
                             "	\n"
                             "	\n"
                             "	combindVertex(poses[0], norms[0]);\n"
                             "	combindVertex(poses[4], norms[4]);\n"
                             "	combindVertex(poses[1], norms[1]);\n"
                             "	combindVertex(poses[5], norms[5]);\n"
                             "	combindVertex(poses[2], norms[2]);\n"
                             "	combindVertex(poses[6], norms[6]);\n"
                             "	combindVertex(poses[3], norms[3]);\n"
                             "	combindVertex(poses[7], norms[7]);\n"
                             "	combindVertex(poses[0], norms[0]);\n"
                             "	combindVertex(poses[4], norms[4]);\n"
                             "	\n"
                             "	EndPrimitive();\n"
                             "}\n"
                             "\n"
;
const char* gcodepreviewG_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 endVertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "in vec2 stepsFlag;\n"
                             "in float visualTypeFlags;\n"
                             "in float lineWidth;\n"
                             "\n"
                             "out vec3 startVertexVS;\n"
                             "out vec3 endVertexVS;\n"
                             "out vec3 vNormalVS;\n"
                             "flat out vec2 stepVS;\n"
                             "flat out float visualTypeVS;\n"
                             "flat out float lineWidthPerStep;\n"
                             "\n"
                             "void main( void )\n"
                             "{	\n"
                             "	startVertexVS = vertexPosition;\n"
                             "	endVertexVS = endVertexPosition;\n"
                             "	vNormalVS = vertexNormal;\n"
                             "	stepVS = stepsFlag;\n"
                             "	visualTypeVS = visualTypeFlags;\n"
                             "	lineWidthPerStep = lineWidth;\n"
                             "}\n"
;
const char* gpuantialiasing_fragment = 
                             "#version 330 core\n"
                             "\n"
                             "out vec4 fragColor0;\n"
                             "out vec4 fragColor1;\n"
                             "out vec4 fragColor2;\n"
                             "out vec4 fragColor3;\n"
                             "out vec4 fragColor4;\n"
                             "out vec4 fragColor5;\n"
                             "out vec4 fragColor6;\n"
                             "out vec4 fragColor7;\n"
                             "\n"
                             "in vec2 texCoord0;\n"
                             "\n"
                             "uniform vec2 textureSize;\n"
                             "uniform sampler2D mainTexture0;\n"
                             "uniform sampler2D mainTexture1;\n"
                             "uniform sampler2D mainTexture2;\n"
                             "uniform sampler2D mainTexture3;\n"
                             "uniform sampler2D mainTexture4;\n"
                             "uniform sampler2D mainTexture5;\n"
                             "uniform sampler2D mainTexture6;\n"
                             "uniform sampler2D mainTexture7;\n"
                             "\n"
                             "uniform int antiflag;\n"
                             "\n"
                             "#ifndef FXAA_REDUCE_MIN  \n"
                             "#define FXAA_REDUCE_MIN   (1.0/ 128.0)  \n"
                             "#endif  \n"
                             "#ifndef FXAA_REDUCE_MUL  \n"
                             "#define FXAA_REDUCE_MUL   (1.0 / 8.0)  \n"
                             "#endif  \n"
                             "#ifndef FXAA_SPAN_MAX  \n"
                             "#define FXAA_SPAN_MAX     8.0  \n"
                             "#endif\n"
                             "  \n"
                             "vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,  \n"
                             "	vec2 v_rgbNW, vec2 v_rgbNE,  \n"
                             "	vec2 v_rgbSW, vec2 v_rgbSE,  \n"
                             "	vec2 v_rgbM) \n"
                             "{  \n"
                             "	vec4 color;  \n"
                             "	mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);  \n"
                             "	vec3 rgbNW = texture(tex, v_rgbNW).xyz;  \n"
                             "	vec3 rgbNE = texture(tex, v_rgbNE).xyz;  \n"
                             "	vec3 rgbSW = texture(tex, v_rgbSW).xyz;  \n"
                             "	vec3 rgbSE = texture(tex, v_rgbSE).xyz;  \n"
                             "	vec4 texColor = texture(tex, v_rgbM);  \n"
                             "	vec3 rgbM = texColor.xyz;  \n"
                             "	vec3 luma = vec3(0.299, 0.587, 0.114);  \n"
                             "	float lumaNW = dot(rgbNW, luma);  \n"
                             "	float lumaNE = dot(rgbNE, luma);  \n"
                             "	float lumaSW = dot(rgbSW, luma);  \n"
                             "	float lumaSE = dot(rgbSE, luma);  \n"
                             "	float lumaM = dot(rgbM, luma);  \n"
                             "	float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));  \n"
                             "	float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));  \n"
                             "\n"
                             "	mediump vec2 dir;  \n"
                             "	dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));  \n"
                             "	dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));  \n"
                             "\n"
                             "	float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);  \n"
                             "\n"
                             "	float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);  \n"
                             "	dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),  \n"
                             "		max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),  \n"
                             "			dir * rcpDirMin)) * inverseVP;  \n"
                             "\n"
                             "	vec3 rgbA = 0.5 * (  \n"
                             "		texture(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +  \n"
                             "		texture(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);  \n"
                             "	vec3 rgbB = rgbA * 0.5 + 0.25 * (  \n"
                             "		texture(tex, fragCoord * inverseVP + dir * -0.5).xyz +  \n"
                             "		texture(tex, fragCoord * inverseVP + dir * 0.5).xyz);  \n"
                             "\n"
                             "	float lumaB = dot(rgbB, luma);  \n"
                             "	if ((lumaB < lumaMin) || (lumaB > lumaMax))  \n"
                             "	color = vec4(rgbA, texColor.a);  \n"
                             "	else  \n"
                             "	color = vec4(rgbB, texColor.a);  \n"
                             "	return color;  \n"
                             "}  \n"
                             "\n"
                             "void texcoords(vec2 fragCoord, vec2 resolution,  \n"
                             "	out vec2 v_rgbNW, out vec2 v_rgbNE,  \n"
                             "	out vec2 v_rgbSW, out vec2 v_rgbSE,  \n"
                             "	out vec2 v_rgbM) \n"
                             "{  \n"
                             "	vec2 inverseVP = 1.0 / resolution.xy;  \n"
                             "	v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;  \n"
                             "	v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;  \n"
                             "	v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;  \n"
                             "	v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;  \n"
                             "	v_rgbM = vec2(fragCoord * inverseVP);  \n"
                             "}\n"
                             "\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	if(antiflag == 1)\n"
                             "	{\n"
                             "		vec2 fragCoord = gl_FragCoord.xy;\n"
                             "		\n"
                             "		vec2 v_rgbNW;\n"
                             "		vec2 v_rgbNE;\n"
                             "		vec2 v_rgbSW;\n"
                             "		vec2 v_rgbSE;\n"
                             "		vec2 v_rgbM;\n"
                             "		\n"
                             "		texcoords(fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
                             "		\n"
                             "		fragColor0 = fxaa(mainTexture0, fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
                             "		fragColor1 = fxaa(mainTexture1, fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
                             "		fragColor2 = fxaa(mainTexture2, fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
                             "		fragColor3 = fxaa(mainTexture3, fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
                             "		fragColor4 = fxaa(mainTexture4, fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
                             "		fragColor5 = fxaa(mainTexture5, fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
                             "		fragColor6 = fxaa(mainTexture6, fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
                             "		fragColor7 = fxaa(mainTexture7, fragCoord, textureSize, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
                             "	\n"
                             "	}\n"
                             "	else\n"
                             "	{\n"
                             "		fragColor0 = texture2D(mainTexture0, texCoord0);\n"
                             "		fragColor1 = texture2D(mainTexture1, texCoord0);\n"
                             "		fragColor2 = texture2D(mainTexture2, texCoord0);\n"
                             "		fragColor3 = texture2D(mainTexture3, texCoord0);\n"
                             "		fragColor4 = texture2D(mainTexture4, texCoord0);\n"
                             "		fragColor5 = texture2D(mainTexture5, texCoord0);\n"
                             "		fragColor6 = texture2D(mainTexture6, texCoord0);\n"
                             "		fragColor7 = texture2D(mainTexture7, texCoord0);\n"
                             "\n"
                             "	}\n"
                             "}\n"
;
const char* gpuantialiasing_vert = 
                             "#version 330 core\n"
                             "in vec3 vertexPosition;\n"
                             "in vec2 vertexTexCoord;\n"
                             "out vec2 texCoord0;\n"
                             "void main()\n"
                             "{\n"
                             "   gl_Position = vec4(vertexPosition, 1.0);\n"
                             "   texCoord0 = vertexTexCoord;\n"
                             "}\n"
;
const char* modeldlp_fragment = 
                             "#version 150 core\n"
                             "out vec4 fragmentColor;\n"
                             " \n"
                             "in vec3 viewDirection;\n"
                             "in vec3 vertexnormal;\n"
                             "in vec3 worldPosition;\n"
                             "in vec3 gnormal;\n"
                             "\n"
                             "uniform int state;\n"
                             "uniform float error;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform float specularPower = 4.5;  // 12.0\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 clipPlane1;\n"
                             "uniform vec4 clipPlane2;\n"
                             "\n"
                             "uniform int checkScope = 1;\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float supportCos = 0.5;\n"
                             "\n"
                             "uniform int hoverState = 0;\n"
                             "uniform int waterState = 0;\n"
                             "\n"
                             "const float zcha = 0.1;\n"
                             "\n"
                             "uniform vec4 stateColors[6];\n"
                             "uniform vec3 water;\n"
                             "bool frontFacing()\n"
                             "{\n"
                             "        vec3 fdx = dFdx(worldPosition);\n"
                             "        vec3 fdy = dFdy(worldPosition);\n"
                             "        return dot(gnormal, cross(fdx, fdy)) > 0.0;\n"
                             "}\n"
                             "float distance2Plane(vec3 position, vec4 plane)\n"
                             "{\n"
                             "	vec3 p = position - vec3(0.0, 0.0, plane.w);\n"
                             "	return dot(p, plane.xyz);\n"
                             "}\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(distance2Plane(worldPosition, clipPlane1) < 0.0)\n"
                             "		discard;\n"
                             "\n"
                             "	if(distance2Plane(worldPosition, clipPlane2) < 0.0)\n"
                             "		discard;\n"
                             "		\n"
                             "	vec4 color = stateColors[state];\n"
                             "	color = error * stateColors[3] + (1.0 - error) * color;	\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(vertexnormal);\n"
                             "	vec3 fgnormal = normalize(gnormal);\n"
                             "		\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "\n"
                             "	if(!frontFacing())\n"
                             "	{\n"
                             "		color = vec4(stateColors[5].xyz, 1.0);\n"
                             "		fnormal = - fnormal;\n"
                             "	}\n"
                             "	\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient, diffuse, specular);	\n"
                             "	if(checkScope > 0)\n"
                             "	{\n"
                             "		if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < 0.1 || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	\n"
                             "	if(hoverState > 0)\n"
                             "	{\n"
                             "		float v = dot(fgnormal, vec3(0.0, 0.0, -1.0));\n"
                             "		if(v >= supportCos)\n"
                             "		{\n"
                             "			coreColor.r += 0.8 * v;\n"
                             "		}\n"
                             "		\n"
                             "		if(waterState == 1)\n"
                             "		{\n"
                             "			if(abs(worldPosition.z - water.z) < zcha)\n"
                             "			{\n"
                             "				coreColor = vec4(0.1, 0.1, 0.1, 1.0);\n"
                             "			}\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	fragmentColor = vec4(coreColor.rgb, 1.0);\n"
                             "}\n"
;
const char* modeldlp_geom = 
                             "#version 330\n"
                             "\n"
                             "layout (triangles) in;\n"
                             "layout (triangle_strip,max_vertices = 3) out;\n"
                             "\n"
                             "in VS_OUT {\n"
                             "vec3 vert;\n"
                             "} gs_in[];\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 vertexnormal;\n"
                             "out vec3 worldPosition;\n"
                             "out vec3 gnormal;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "\n"
                             "worldPosition = vec3(modelMatrix * vec4(gs_in[0].vert, 1.0));\n"
                             "vec4 tworldPosition0 = modelViewMatrix * vec4(gs_in[0].vert, 1.0);\n"
                             "viewDirection = normalize(vec3(-tworldPosition0));\n"
                             "vec3 a = gs_in[1].vert - gs_in[0].vert;\n"
                             "vec3 b = gs_in[2].vert - gs_in[1].vert;\n"
                             "vec3 tmpCross = cross(a, b);\n"
                             "vertexnormal = normalize(mat3(viewMatrix) * mat3(modelMatrix) * tmpCross);\n"
                             "gnormal = normalize(mat3(modelMatrix) * tmpCross);\n"
                             "\n"
                             "gl_Position = projectionMatrix * tworldPosition0;\n"
                             "EmitVertex();\n"
                             "\n"
                             "worldPosition = vec3(modelMatrix * vec4(gs_in[1].vert, 1.0));\n"
                             "vec4 tworldPosition1 = modelViewMatrix * vec4(gs_in[1].vert, 1.0);\n"
                             "viewDirection = normalize(vec3(-tworldPosition1));\n"
                             "gl_Position = projectionMatrix * tworldPosition1;\n"
                             "EmitVertex();\n"
                             "\n"
                             "worldPosition = vec3(modelMatrix * vec4(gs_in[2].vert, 1.0));\n"
                             "vec4 tworldPosition2 = modelViewMatrix * vec4(gs_in[2].vert, 1.0);\n"
                             "viewDirection = normalize(vec3(-tworldPosition2));\n"
                             "gl_Position = projectionMatrix * tworldPosition2;\n"
                             "EmitVertex();\n"
                             "\n"
                             "EndPrimitive();\n"
                             "}\n"
;
const char* modeldlp_vert = 
                             "#version 330 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "out VS_OUT {\n"
                             "vec3 vert;\n"
                             "} vs_out;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	vs_out.vert = vertexPosition;\n"
                             "}\n"
;
const char* modelface_fragment = 
                             "#version 150 core\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "in vec3 gnormal;\n"
                             "in vec3 worldPosition;\n"
                             "in vec3 worldWater;\n"
                             "in vec3 gcolor;\n"
                             "in vec2 varyUV;\n"
                             "\n"
                             "uniform float transparency = 1.0;\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "uniform float error;\n"
                             "uniform float supportCos = 0.5;\n"
                             "\n"
                             "uniform int hoverState = 0;\n"
                             "uniform int checkscope = 1;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform float nozzle;\n"
                             "uniform vec4 stateColors[6];\n"
                             "uniform int renderModel = 1;\n"
                             "uniform int useVertexColor = 0;\n"
                             "\n"
                             "uniform sampler2D textureDiffuse;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "const float specularPower = 4.5;\n"
                             "\n"
                             "bool frontFacing()\n"
                             "{\n"
                             "    vec3 fdx = dFdx(worldPosition);\n"
                             "    vec3 fdy = dFdy(worldPosition);\n"
                             "    return dot(gnormal, cross(fdx, fdy)) > 0.0;\n"
                             "} \n"
                             "\n"
                             "vec4 directLight(vec3 lightDir, vec3 fnormal, vec4 coreColor, vec4 ambient, vec4 diffuse, vec4 specular) \n"
                             "{\n"
                             "    /* ambient */\n"
                             "	vec4 ambientColor = ambient * coreColor;\n"
                             "\n"
                             "    /* diffuse */\n"
                             "	float NdotL = max(dot(fnormal, lightDir), 0.0);\n"
                             "	vec4 diffuseColor = NdotL * diffuse * coreColor;\n"
                             "\n"
                             "    /* specular */\n"
                             "	vec3 freflection = reflect(-lightDir, fnormal);\n"
                             "	vec3 fViewDirection = normalize(viewDirection);\n"
                             "	float RdotV = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 specularColor = specular * pow( RdotV, specularPower) * coreColor;\n"
                             "	\n"
                             "	return ambientColor + diffuseColor + specularColor;\n"
                             "}\n"
                             "\n"
                             "vec4 getColor()\n"
                             "{\n"
                             "	int stateInt = int(state);\n"
                             "    if (error > 0)\n"
                             "        return stateColors[3];\n"
                             "    else \n"
                             "    {\n"
                             "        // if (useVertexColor == 1 && stateInt == 0) \n"
                             "		//     return vec4(gcolor, 1.0);\n"
                             "        // else\n"
                             "        return stateColors[stateInt];\n"
                             "    }\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if (checkscope > 0 && (worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight))\n"
                             "		discard;\n"
                             "\n"
                             "	vec3 fgnormal =	normalize(gnormal);\n"
                             "    vec3 lightDirection = vec3(1.0, 0.0, 1.0);\n"
                             "    vec3 fnormal 		  =	normalize(normal);\n"
                             "    vec4 _ambient = ambient;\n"
                             "    vec4 _diffuse = diffuse;\n"
                             "    vec4 _specular = specular;\n"
                             "    vec3 lightDir;\n"
                             "    vec4 color;\n"
                             "\n"
                             "    if (frontFacing())\n"
                             "    {   /* 外壁渲染参数 */\n"
                             "        lightDir = normalize(dot(fnormal, lightDirection) * lightDirection);\n"
                             "        if(checkscope > 0 && \n"
                             "            (worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z || \n"
                             "             worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z ||\n"
                             "             abs(worldPosition.z - bottom) < 0.05))\n"
                             "        {   /* 越界部分颜色 */\n"
                             "            color = stateColors[4];\n"
                             "        } \n"
                             "        else \n"
                             "        {\n"
                             "            color = getColor();\n"
                             "\n"
                             "            if (hoverState > 0)\n"
                             "            {   \n"
                             "                float v = dot(fgnormal, vec3(0.0, 0.0, -1.0));\n"
                             "                color.r += (int(v >= supportCos) * 0.8 * v);\n"
                             "            }\n"
                             "            \n"
                             "            color.rgb = color.rgb + vec3(0.1, -0.1, 0.0) * nozzle;\n"
                             "        }\n"
                             "    }\n"
                             "    else \n"
                             "    {   /* 内壁渲染参数 */\n"
                             "        _ambient = _ambient + vec4(0.2, 0.2, 0.2, 0.0);\n"
                             "        _diffuse = _diffuse + vec4(0.08, 0.08, 0.08, 0.0);\n"
                             "        lightDir = normalize(lightDirection);\n"
                             "        fnormal = -fnormal;\n"
                             "        color = stateColors[5];   \n"
                             "    }\n"
                             "\n"
                             "    color = directLight(lightDir, fnormal, color, _ambient, _diffuse, _specular);\n"
                             "    fragColor = vec4(color.rgb, transparency);\n"
                             "} \n"
                             "\n"
                             "\n"
;
const char* modelface_vert = 
                             "#version 150 core\n"
                             "/* modelwireframe.vert */\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "in vec2 vertexTexCoord;\n"
                             "in vec3 vertexColor;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec3 gnormal;\n"
                             "out vec3 worldPosition;\n"
                             "out vec2 varyUV;\n"
                             "out vec3 gcolor;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "    gnormal        = mat3(modelMatrix) * vertexNormal;\n"
                             "		\n"
                             "    worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "	varyUV = vertexTexCoord;\n"
                             "    gcolor      = vertexColor;\n"
                             "\n"
                             "}\n"
;
const char* modelwire_fragment = 
                             "#version 150 core\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "in vec3 gnormal;\n"
                             "in vec3 worldPosition;\n"
                             "in vec3 worldWater;\n"
                             "in vec3 barycentric;\n"
                             "in vec3 gcolor;\n"
                             "\n"
                             "uniform int lightingEnable = 1;\n"
                             "uniform float transparency = 1.0;\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "uniform float error;\n"
                             "uniform float supportCos = 0.5;\n"
                             "\n"
                             "uniform int hoverState = 0;\n"
                             "uniform int checkscope = 1;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform float nozzle;\n"
                             "uniform vec4 stateColors[6];\n"
                             "uniform int renderModel = 1;\n"
                             "uniform vec3 wireframeColor = vec3(0.1);\n"
                             "uniform vec3 clearColor = vec3(0.27);\n"
                             "\n"
                             "uniform sampler2D textureDiffuse;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "const float specularPower = 4.5;\n"
                             "\n"
                             "in vec2 varyUV;\n"
                             "\n"
                             "bool frontFacing()\n"
                             "{\n"
                             "        vec3 fdx = dFdx(worldPosition);\n"
                             "        vec3 fdy = dFdy(worldPosition);\n"
                             "        return dot(gnormal, cross(fdx, fdy)) > 0.0;\n"
                             "} \n"
                             "\n"
                             "vec4 directLight(vec3 lightDir, vec3 fnormal, vec4 coreColor, vec4 ambient, vec4 diffuse, vec4 specular) \n"
                             "{\n"
                             "    /* ambient */\n"
                             "	vec4 ambientColor = ambient * coreColor;\n"
                             "\n"
                             "    /* diffuse */\n"
                             "	float NdotL = max(dot(fnormal, lightDir), 0.0);\n"
                             "	vec4 diffuseColor = NdotL * diffuse * coreColor;\n"
                             "\n"
                             "    /* specular */\n"
                             "	vec3 freflection = reflect(-lightDir, fnormal);\n"
                             "	vec3 fViewDirection = normalize(viewDirection);\n"
                             "	float RdotV = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 specularColor = specular * pow( RdotV, specularPower) * coreColor;\n"
                             "	\n"
                             "	return ambientColor + diffuseColor + specularColor;\n"
                             "}\n"
                             "\n"
                             "vec4 getColor()\n"
                             "{\n"
                             "	int stateInt = int(state);\n"
                             "    if (error > 0)\n"
                             "        return stateColors[3];\n"
                             "    else \n"
                             "    {\n"
                             "        // if (useVertexColor == 1 && stateInt == 0) \n"
                             "		//     return vec4(gcolor, 1.0);\n"
                             "        // else\n"
                             "        return stateColors[stateInt];\n"
                             "    }\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(renderModel == 1 ||\n"
                             "       (checkscope > 0 && (worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight)))\n"
                             "		discard;\n"
                             "\n"
                             "	vec3 baryDelta = fwidth(barycentric);	\n"
                             "	vec3 edgeFactor = smoothstep(vec3(0.0), baryDelta * 1.0, barycentric);\n"
                             "	float minEdgeFactor = min(min(edgeFactor.x, edgeFactor.y), edgeFactor.z);\n"
                             "    vec4 color;\n"
                             "\n"
                             "    if (renderModel == 2) \n"
                             "    {   /* 只显示线 */\n"
                             "		if (minEdgeFactor >= 1.0) \n"
                             "            discard;\n"
                             "        color.rgb = clearColor;\n"
                             "	} \n"
                             "    else if (renderModel == 3) \n"
                             "    {   /* 显示线+面 */\n"
                             "        vec3 fgnormal =	normalize(gnormal);\n"
                             "        vec3 lightDirection = vec3(1.0, 0.0, 1.0);\n"
                             "        vec3 fnormal 		  =	normalize(normal);\n"
                             "        vec4 _ambient = ambient;\n"
                             "        vec4 _diffuse = diffuse;\n"
                             "        vec4 _specular = specular;\n"
                             "        vec3 lightDir;\n"
                             "\n"
                             "        if(frontFacing())\n"
                             "        {   /* 外壁渲染参数 */\n"
                             "            lightDir = normalize(dot(fnormal, lightDirection) * lightDirection);\n"
                             "            if(checkscope > 0 && \n"
                             "                (worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z || \n"
                             "                worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z ||\n"
                             "                abs(worldPosition.z - bottom) < 0.05))\n"
                             "            {   /* 越界部分颜色 */\n"
                             "                color = stateColors[4];\n"
                             "            } \n"
                             "            else \n"
                             "            {\n"
                             "                color = getColor();\n"
                             "\n"
                             "                if(hoverState > 0)\n"
                             "                {   \n"
                             "                    float v = dot(fgnormal, vec3(0.0, 0.0, -1.0));\n"
                             "                    color.r += (int(v >= supportCos) * 0.8 * v);\n"
                             "                }\n"
                             "                \n"
                             "                color.rgb = color.rgb + vec3(0.1, -0.1, 0.0) * nozzle;\n"
                             "            }\n"
                             "        }\n"
                             "        else \n"
                             "        {   /* 内壁渲染参数 */\n"
                             "            _ambient = _ambient + vec4(0.2, 0.2, 0.2, 0.0);\n"
                             "            _diffuse = _diffuse + vec4(0.08, 0.08, 0.08, 0.0);\n"
                             "            lightDir = normalize(lightDirection);\n"
                             "            fnormal = -fnormal;\n"
                             "            color = stateColors[5];  \n"
                             "        }\n"
                             "        color = directLight(lightDir, fnormal, color, ambient, diffuse, specular);\n"
                             "    }\n"
                             "    color.rgb = mix(wireframeColor, color.rgb, minEdgeFactor);\n"
                             "	fragColor = vec4(color.rgb, transparency);\n"
                             "}\n"
                             "\n"
;
const char* modelwire_geom = 
                             "#version 150 core\n"
                             "\n"
                             "layout (triangles) in;\n"
                             "layout (triangle_strip, max_vertices = 3) out;\n"
                             "\n"
                             "in vec3 viewDirectionVS[3];\n"
                             "in vec3 normalVS[3];\n"
                             "in vec3 gnormalVS[3];\n"
                             "in vec3 worldPositionVS[3];\n"
                             "in vec2 varyUVVS[3];\n"
                             "in vec3 colorVS[3];\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec3 gnormal;\n"
                             "out vec3 worldPosition;\n"
                             "out vec3 barycentric;\n"
                             "out vec2 varyUV;\n"
                             "out vec3 gcolor;\n"
                             "\n"
                             "void combindVertex(int index)\n"
                             "{\n"
                             "    gl_Position = gl_in[index].gl_Position;\n"
                             "\n"
                             "    viewDirection = viewDirectionVS[index];\n"
                             "    normal = normalVS[index];\n"
                             "    gnormal = gnormalVS[index];\n"
                             "    worldPosition = worldPositionVS[index];\n"
                             "	\n"
                             "	varyUV = varyUVVS[index];\n"
                             "    gcolor =  colorVS[index];\n"
                             "\n"
                             "    EmitVertex();\n"
                             "}\n"
                             "\n"
                             "\n"
                             "void main() {\n"
                             "    \n"
                             "    barycentric = vec3(1.0, 0.0, 0.0);\n"
                             "    combindVertex(0);\n"
                             "    \n"
                             "    barycentric = vec3(0.0, 1.0, 0.0);\n"
                             "    combindVertex(1);\n"
                             "\n"
                             "    barycentric = vec3(0.0, 0.0, 1.0);\n"
                             "    combindVertex(2);\n"
                             "\n"
                             "    EndPrimitive();\n"
                             "}\n"
;
const char* modelwire_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "in vec2 vertexTexCoord;\n"
                             "in vec3 vertexColor;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirectionVS;\n"
                             "out vec3 normalVS;\n"
                             "out vec3 gnormalVS;\n"
                             "out vec3 worldPositionVS;\n"
                             "out vec2 varyUVVS;\n"
                             "out vec3 colorVS;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirectionVS  = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normalVS          = normalMatrix * vertexNormal;\n"
                             "    gnormalVS        = mat3(modelMatrix) * vertexNormal;\n"
                             "		\n"
                             "    worldPositionVS   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "	varyUVVS = vertexTexCoord;\n"
                             "    colorVS      = vertexColor;\n"
                             "}\n"
;
const char* modelwireframe_fragment = 
                             "#version 150 core\n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "in vec3 gnormal;\n"
                             "in vec3 worldPosition;\n"
                             "in vec3 worldWater;\n"
                             "in vec3 barycentric;\n"
                             "in vec3 gcolor;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform vec4 specular = vec4(0.8, 0.8, 0.8, 1.0);\n"
                             "uniform float specularPower = 4.5;\n"
                             "uniform vec3 lightDirection = vec3(1.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform int lightingEnable = 1;\n"
                             "uniform float transparency = 1.0;\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "uniform float error;\n"
                             "uniform float supportCos = 0.5;\n"
                             "\n"
                             "uniform int hoverState = 0;\n"
                             "uniform int fanzhuan = 0;\n"
                             "uniform int checkscope = 1;\n"
                             "\n"
                             "uniform float state;\n"
                             "uniform float nozzle;\n"
                             "uniform vec4 stateColors[6];\n"
                             "uniform vec4 customColor;\n"
                             "\n"
                             "uniform vec3 wireframeColor = vec3(0.1);\n"
                             "uniform vec3 clearColor = vec3(0.27);\n"
                             "uniform int renderModel = 1;\n"
                             "uniform int useVertexColor = 0;\n"
                             "\n"
                             "uniform sampler2D textureDiffuse;\n"
                             "uniform sampler2D textureAmbient;\n"
                             "uniform sampler2D textureSpecular;\n"
                             "uniform sampler2D textureNormal;\n"
                             "\n"
                             "in vec2 varyUV;\n"
                             "\n"
                             "bool frontFacing()\n"
                             "{\n"
                             "        vec3 fdx = dFdx(worldPosition);\n"
                             "        vec3 fdy = dFdy(worldPosition);\n"
                             "        return dot(gnormal, cross(fdx, fdy)) > 0.0;\n"
                             "} \n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return lightingEnable * (ambient_color + diffuse_color + specular_color) + (1 - lightingEnable) * core_color;\n"
                             "}\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(checkscope > 0 && (worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight))\n"
                             "		discard;\n"
                             "\n"
                             "	int stateInt = int(state);\n"
                             "	vec4 color;\n"
                             "	\n"
                             "	if(varyUV.x<0.0||varyUV.y<0.0)\n"
                             "	{\n"
                             "		if (stateInt < 5)\n"
                             "		{\n"
                             "			color = stateColors[stateInt];\n"
                             "			if (useVertexColor == 1 && stateInt == 0) {\n"
                             "				color = vec4(gcolor, 1.0);\n"
                             "			}			\n"
                             "		}\n"
                             "			\n"
                             "		else\n"
                             "			color = customColor;\n"
                             "		\n"
                             "		//if(error == 1.0)\n"
                             "		//	color = stateColors[3];	\n"
                             "	}\n"
                             "	else\n"
                             "	{\n"
                             "		vec4 textColor = texture(textureDiffuse, varyUV);\n"
                             "		if(textColor.r<0 ||textColor.g<0||textColor.b<0)\n"
                             "		{\n"
                             "			textColor=stateColors[0];\n"
                             "		}\n"
                             "		color = textColor;\n"
                             "	}\n"
                             "\n"
                             "	vec4 coreColor = color;\n"
                             "	vec3 fgnormal =	normalize(gnormal);\n"
                             "	\n"
                             "	if(checkscope > 0)\n"
                             "	{\n"
                             "		if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z \n"
                             "		|| worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z\n"
                             "		|| abs(worldPosition.z - bottom) < 0.05 )\n"
                             "		{\n"
                             "			// coreColor = vec4(0.649, 0.516, 0.504, 1.0);\n"
                             "			coreColor = stateColors[4];\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	if(hoverState > 0)\n"
                             "	{\n"
                             "		float v = dot(fgnormal, vec3(0.0, 0.0, -1.0));\n"
                             "		if(v >= supportCos)\n"
                             "		{\n"
                             "			coreColor.r += 0.8 * v;\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "	coreColor.rgb = coreColor.rgb + vec3(0.1, -0.1, 0.0) * nozzle;\n"
                             "\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 ambient_color 	  = ambient;\n"
                             "	vec4 diffuse_color    = diffuse;\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "	float normalCos = dot(fnormal, lightDir);\n"
                             "	if (normalCos >= 0)\n"
                             "		coreColor = directLight(lightDir, fnormal, coreColor, ambient_color, diffuse_color, specular_color);\n"
                             "	else\n"
                             "		coreColor = directLight(-lightDir, fnormal, coreColor, ambient_color, diffuse_color, specular_color);\n"
                             "\n"
                             "	if(!frontFacing())\n"
                             "	{\n"
                             "		color = stateColors[5];   \n"
                             "		vec3 fbnormal = -fnormal;\n"
                             "		vec4 ambient_color_t 	= ambient + vec4(0.2, 0.2, 0.2, 0.0);\n"
                             "		vec4 diffuse_color_t    = diffuse + vec4(0.08, 0.08, 0.08, 0.0);\n"
                             "		vec4 specular_color_t   = specular;\n"
                             "		coreColor = directLight(lightDir, fbnormal, color, ambient_color_t, diffuse_color_t, specular_color_t);\n"
                             "	}\n"
                             "\n"
                             "	if (renderModel != 1) {\n"
                             "		vec3 baryDelta = fwidth(barycentric);\n"
                             "			\n"
                             "		vec3 edgeFactor = smoothstep(vec3(0.0), baryDelta * 1.0, barycentric);\n"
                             "		float minEdgeFactor = min(min(edgeFactor.x, edgeFactor.y), edgeFactor.z);\n"
                             "\n"
                             "		if (renderModel == 2) {\n"
                             "			\n"
                             "			if (minEdgeFactor >= 1.0) {\n"
                             "                discard;\n"
                             "            }\n"
                             "            coreColor.rgb = mix(wireframeColor, clearColor, minEdgeFactor);\n"
                             "\n"
                             "		} else if (renderModel == 3) {\n"
                             "			coreColor.rgb = mix(wireframeColor, coreColor.rgb, minEdgeFactor);\n"
                             "		}\n"
                             "	}\n"
                             "\n"
                             "	fragmentColor = vec4(coreColor.rgb, transparency);\n"
                             "}\n"
;
const char* modelwireframe_geom = 
                             "#version 150 core\n"
                             "\n"
                             "layout (triangles) in;\n"
                             "layout (triangle_strip, max_vertices = 3) out;\n"
                             "\n"
                             "in vec3 viewDirectionVS[3];\n"
                             "in vec3 normalVS[3];\n"
                             "in vec3 gnormalVS[3];\n"
                             "in vec3 worldPositionVS[3];\n"
                             "in vec2 varyUVVS[3];\n"
                             "in vec3 colorVS[3];\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec3 gnormal;\n"
                             "out vec3 worldPosition;\n"
                             "out vec3 barycentric;\n"
                             "out vec2 varyUV;\n"
                             "out vec3 gcolor;\n"
                             "\n"
                             "void combindVertex(int index)\n"
                             "{\n"
                             "    gl_Position = gl_in[index].gl_Position;\n"
                             "\n"
                             "    viewDirection = viewDirectionVS[index];\n"
                             "    normal = normalVS[index];\n"
                             "    gnormal = gnormalVS[index];\n"
                             "    worldPosition = worldPositionVS[index];\n"
                             "	\n"
                             "	varyUV = varyUVVS[index];\n"
                             "    gcolor =  colorVS[index];\n"
                             "\n"
                             "    EmitVertex();\n"
                             "}\n"
                             "\n"
                             "\n"
                             "void main() {\n"
                             "    \n"
                             "    barycentric = vec3(1.0, 0.0, 0.0);\n"
                             "    combindVertex(0);\n"
                             "    \n"
                             "    barycentric = vec3(0.0, 1.0, 0.0);\n"
                             "    combindVertex(1);\n"
                             "\n"
                             "    barycentric = vec3(0.0, 0.0, 1.0);\n"
                             "    combindVertex(2);\n"
                             "\n"
                             "    EndPrimitive();\n"
                             "}\n"
;
const char* modelwireframe_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "in vec2 vertexTexCoord;\n"
                             "in vec3 vertexColor;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirectionVS;\n"
                             "out vec3 normalVS;\n"
                             "out vec3 gnormalVS;\n"
                             "out vec3 worldPositionVS;\n"
                             "out vec2 varyUVVS;\n"
                             "out vec3 colorVS;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "    vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "\n"
                             "    viewDirectionVS  = normalize(vec3(-tworldPosition));\n"
                             "    mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "\n"
                             "    normalVS          = normalMatrix * vertexNormal;\n"
                             "    gnormalVS        = mat3(modelMatrix) * vertexNormal;\n"
                             "		\n"
                             "    worldPositionVS   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "	varyUVVS = vertexTexCoord;\n"
                             "    colorVS      = vertexColor;\n"
                             "}\n"
;
const char* overlay_fragment = 
                             "#version 150 core\n"
                             " \n"
                             "out vec4 fragColor;\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	fragColor = color;\n"
                             "}\n"
;
const char* overlay_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   vec4 pos = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "   pos.z = -pos.w;\n"
                             "   gl_Position = pos;\n"
                             "}\n"
;
const char* phong_fragment = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 normalDir;\n"
                             "in vec3 viewDir;\n"
                             "in vec3 lightDir;\n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "/* factor */\n"
                             "uniform vec4 ambient = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.7, 0.7, 0.7, 1.0);\n"
                             "uniform vec4 specular = vec4(0.5, 0.5, 0.5, 1.0);\n"
                             "uniform float specularPower = 4.5;\n"
                             "\n"
                             "vec4 directLight(vec4 core_color)\n"
                             "{\n"
                             "    /* ambient */\n"
                             "	vec4 ambient_color 	  = ambient * core_color;\n"
                             "\n"
                             "	/* diffuse */\n"
                             "	float NdotL 		  = max(dot(normalDir, lightDir), 0.0);\n"
                             "	vec4 diffuse_color    = NdotL * diffuse * core_color;\n"
                             "\n"
                             "    /* specular */\n"
                             "	vec3 freflection      = reflect(-lightDir, normalDir);\n"
                             "	float RdotV           = max(0.0, dot(freflection, viewDir)); \n"
                             "	vec4 specular_color   = specular * pow(RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	fragColor = directLight(color);\n"
                             "}\n"
;
const char* phong_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "\n"
                             "out vec3 normalDir;\n"
                             "out vec3 viewDir;\n"
                             "out vec3 lightDir;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform vec3 u_lightDir = vec3(0.0, 1.0, 0.8);\n"
                             "\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   vec3 view_position = vec3(viewMatrix * modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "	viewDir = normalize(-view_position);\n"
                             "\n"
                             "   normalDir = normalize(mat3(viewMatrix * modelMatrix) * vertexNormal);\n"
                             "\n"
                             "   vec3 light = mat3(viewMatrix) * u_lightDir;\n"
                             "   lightDir = normalize(light);\n"
                             "\n"
                             "   gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "}\n"
;
const char* pickFace_fragment = 
                             "#version 330 core \n"
                             "\n"
                             "uniform ivec2 vertexBase;\n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	int ids[2];\n"
                             "	ids[0] = int(gl_PrimitiveID) + int(vertexBase.x / 3);\n"
                             "	ids[1] = int(vertexBase.x / 3);\n"
                             "	\n"
                             "	int _faceId = ids[vertexBase.y];\n"
                             "	int i3 = _faceId / 0x1000000;\n"
                             "	_faceId = _faceId - i3 * 0x1000000;\n"
                             "	int i2 = _faceId / 0x10000;\n"
                             "	_faceId = _faceId - i2 * 0x10000;\n"
                             "	int i1 = _faceId / 0x100;\n"
                             "	_faceId = _faceId - i1 * 0x100;\n"
                             "	int i0 = _faceId;\n"
                             "	\n"
                             "	fragColor = vec4(\n"
                             "					float(i0) / 255.0,\n"
                             "					float(i1) / 255.0,\n"
                             "					float(i2) / 255.0,\n"
                             "					float(i3) / 255.0);\n"
                             "	\n"
                             "}\n"
;
const char* pickFace_vert = 
                             "#version 330 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 modelMatrix;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	vec4 position = vec4(vertexPosition, 1.0);\n"
                             "\n"
                             "	gl_Position = projectionMatrix * viewMatrix * modelMatrix * position;\n"
                             "}\n"
;
const char* pickFaceFlag_fragment = 
                             "#version 150 core \n"
                             "\n"
                             "flat in vec4 passColor;\n"
                             "in vec3 passVert;\n"
                             "in float flag;\n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	if(flag == 0.0)\n"
                             "		discard;\n"
                             "	fragColor = passColor;\n"
                             "}\n"
;
const char* pickFaceFlag_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in float vertexFlag;\n"
                             "\n"
                             "flat out vec4 passColor;\n"
                             "out vec3 passVert;\n"
                             "out float flag;\n"
                             "\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform ivec2 vertexBase;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	int ids[2];\n"
                             "	ids[0] = int(gl_VertexID / 3.0) + int(vertexBase.x / 3);\n"
                             "	ids[1] = int(vertexBase.x / 3);\n"
                             "	\n"
                             "	int _faceId = ids[vertexBase.y];\n"
                             "	int i3 = _faceId / 0x1000000;\n"
                             "	_faceId = _faceId - i3 * 0x1000000;\n"
                             "	int i2 = _faceId / 0x10000;\n"
                             "	_faceId = _faceId - i2 * 0x10000;\n"
                             "	int i1 = _faceId / 0x100;\n"
                             "	_faceId = _faceId - i1 * 0x100;\n"
                             "	int i0 = _faceId;\n"
                             "	\n"
                             "	vec4 position = vec4(vertexPosition, 1.0);\n"
                             "	passColor = vec4(\n"
                             "					float(i0) / 255.0,\n"
                             "					float(i1) / 255.0,\n"
                             "					float(i2) / 255.0,\n"
                             "					float(i3) / 255.0);\n"
                             "	\n"
                             "	passVert = (modelMatrix * position).xyz;\n"
                             "	gl_Position = projectionMatrix * viewMatrix * modelMatrix * position;\n"
                             "	flag			= vertexFlag;\n"
                             "}\n"
;
const char* pickFace_pwd_fragment = 
                             "#version 330 core\n"
                             "\n"
                             "in vec3 passVert;\n"
                             "in vec3 passNormal;\n"
                             "\n"
                             "layout (location = 0) out vec4 fragColor;\n"
                             "layout (location = 1) out vec3 worldPosion;\n"
                             "layout (location = 2) out vec3 worldNormal;\n"
                             "\n"
                             "uniform ivec2 vertexBase;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	int ids[2];\n"
                             "	ids[0] = int(gl_PrimitiveID) + int(vertexBase.x / 3);\n"
                             "	ids[1] = int(vertexBase.x / 3);\n"
                             "	\n"
                             "	int _faceId = ids[vertexBase.y];\n"
                             "	int i3 = _faceId / 0x1000000;\n"
                             "	_faceId = _faceId - i3 * 0x1000000;\n"
                             "	int i2 = _faceId / 0x10000;\n"
                             "	_faceId = _faceId - i2 * 0x10000;\n"
                             "	int i1 = _faceId / 0x100;\n"
                             "	_faceId = _faceId - i1 * 0x100;\n"
                             "	int i0 = _faceId;\n"
                             "	\n"
                             "	fragColor = vec4(\n"
                             "					float(i0) / 255.0,\n"
                             "					float(i1) / 255.0,\n"
                             "					float(i2) / 255.0,\n"
                             "					float(i3) / 255.0);\n"
                             "					\n"
                             "	worldPosion = passVert;\n"
                             "	worldNormal = passNormal;\n"
                             "}\n"
;
const char* pickFace_pwd_vert = 
                             "#version 330 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "\n"
                             "out vec3 passVert;\n"
                             "out vec3 passNormal;\n"
                             "\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 modelMatrix;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	vec4 position = vec4(vertexPosition, 1.0);\n"
                             "	\n"
                             "	passVert = (modelMatrix * position).xyz;\n"
                             "	passNormal = mat3(modelMatrix) * vertexNormal;\n"
                             "	gl_Position = projectionMatrix * viewMatrix * modelMatrix * position;\n"
                             "\n"
                             "}\n"
;
const char* pickindicator_fragment = 
                             "#version 330 core\n"
                             "\n"
                             "flat in vec4 passColor;\n"
                             "\n"
                             "in vec3 passVert;\n"
                             "in vec3 passNormal;\n"
                             "\n"
                             "layout (location = 0) out vec4 fragColor;\n"
                             "layout (location = 1) out vec3 worldPosion;\n"
                             "layout (location = 2) out vec3 worldNormal;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	fragColor = passColor;\n"
                             "	worldPosion = passVert;\n"
                             "	worldNormal = passNormal;\n"
                             "}\n"
                             " \n"
;
const char* pickindicator_vert = 
                             "#version 330 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "in vec2 vertexTexCoord;\n"
                             "in float facesIndex;\n"
                             "\n"
                             "flat out vec4 passColor;\n"
                             "\n"
                             "out vec3 passVert;\n"
                             "out vec3 passNormal;\n"
                             "\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewportMatrix;\n"
                             "uniform ivec2 vertexBase;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "\n"
                             "	int _faceId =  int(facesIndex) + int(vertexBase.x / 3);;\n"
                             "	int i3 = _faceId / 0x1000000;\n"
                             "	_faceId = _faceId - i3 * 0x1000000;\n"
                             "	int i2 = _faceId / 0x10000;\n"
                             "	_faceId = _faceId - i2 * 0x10000;\n"
                             "	int i1 = _faceId / 0x100;\n"
                             "	_faceId = _faceId - i1 * 0x100;\n"
                             "	int i0 = _faceId;\n"
                             "	\n"
                             "	vec4 position = vec4(vertexPosition, 1.0);\n"
                             "	passColor = vec4(\n"
                             "					float(i0) / 255.0,\n"
                             "					float(i1) / 255.0,\n"
                             "					float(i2) / 255.0,\n"
                             "					float(i3) / 255.0);\n"
                             "	\n"
                             "	passVert = (modelMatrix * position).xyz;\n"
                             "	passNormal = mat3(modelMatrix) * vertexNormal;\n"
                             "	gl_Position = viewportMatrix * projectionMatrix * viewMatrix * modelMatrix * position;\n"
                             "\n"
                             "}\n"
;
const char* piefade_fragment = 
                             "#version 150 core\n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "in vec3 normal;\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 world_position;\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "uniform int rotMode;\n"
                             "uniform float rotRadians;\n"
                             "uniform vec3 rotCenter;\n"
                             "uniform vec3 rotInitDir;\n"
                             "uniform vec3 rotAxis;\n"
                             "\n"
                             "uniform int lightEnable = 0;\n"
                             "uniform vec3 lightDirection = vec3(1.0, 0.0, 1.0);\n"
                             "uniform vec4 ambient = vec4(0.6, 0.6, 0.6, 1.0);\n"
                             "uniform vec4 diffuse = vec4(0.6, 0.6, 0.6, 1.0);\n"
                             "uniform vec4 specular = vec4(0.6, 0.6, 0.6, 1.0);\n"
                             "uniform float specularPower = 4.5;\n"
                             "\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	if (rotMode > 0)\n"
                             "	{\n"
                             "		if (rotRadians == 0.0)\n"
                             "			discard;\n"
                             "		else\n"
                             "		{\n"
                             "			vec3 curDir = normalize(world_position - rotCenter);\n"
                             "			float curRadians = acos(dot(curDir, rotInitDir));\n"
                             "			vec3 curAxis = cross(rotInitDir, curDir);\n"
                             "			float axisInvertCos = dot(rotAxis, curAxis);\n"
                             "			if (axisInvertCos < 0.0)\n"
                             "				curRadians = 2 * 3.14159265357 - curRadians;\n"
                             "		\n"
                             "			if (rotRadians > 0 && curRadians > rotRadians)\n"
                             "				discard;\n"
                             "			else if (rotRadians < 0 && curRadians - 2 * 3.14159265357 < rotRadians)\n"
                             "				discard;\n"
                             "		}\n"
                             "	}\n"
                             "\n"
                             "	vec4 coreColor = color;\n"
                             "\n"
                             "	if (lightEnable > 0)\n"
                             "	{\n"
                             "		vec3 fnormal = normalize(normal);\n"
                             "		vec4 ambient_color = ambient;\n"
                             "		vec4 diffuse_color = diffuse;\n"
                             "		vec4 specular_color = specular;\n"
                             "\n"
                             "		vec3 lightDir = normalize(lightDirection);\n"
                             "		float normalCos = dot(fnormal, lightDir);\n"
                             "		coreColor = directLight(lightDir, fnormal, coreColor, ambient_color, diffuse_color, specular_color);\n"
                             "	}\n"
                             "		\n"
                             "	fragColor = coreColor;\n"
                             "}\n"
;
const char* piefade_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "\n"
                             "out vec3 normal;\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 world_position;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   world_position = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "   vec3 view_position = vec3(viewMatrix * modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "   viewDirection  = normalize(view_position);\n"
                             "   normal = mat3(viewMatrix * modelMatrix) * vertexNormal;\n"
                             "   gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "}\n"
;
const char* pointInGcode_fragment = 
                             "#version 150 core\n"
                             "\n"
                             "in vec2 flags;\n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "uniform vec4 color;\n"
                             "uniform vec4 darkColor = vec4(0.161, 0.161, 0.161, 1.0);\n"
                             "\n"
                             "uniform vec4 clipValue = vec4(0.0, 200.0, 0.0, 300.0);\n"
                             "uniform vec2 layershow = vec2(-1.0, 9999999.0);\n"
                             "\n"
                             "uniform int animation = 0;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	if (flags.x < clipValue.x || flags.x > clipValue.y)\n"
                             "		discard;\n"
                             "		\n"
                             "	if (flags.x == clipValue.y && (flags.y < clipValue.z || flags.y > clipValue.w))\n"
                             "		discard;\n"
                             "\n"
                             "	if (flags.x < layershow.x || flags.x > layershow.y)\n"
                             "		discard;\n"
                             "\n"
                             "	fragColor = (animation == 1 && flags.x != clipValue.y) ? darkColor : color;\n"
                             "}\n"
;
const char* pointInGcode_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "// in vec3 vertexNormal;\n"
                             "\n"
                             "// in vec3 worldPos;\n"
                             "in vec2 stepsFlag;\n"
                             "\n"
                             "out vec2 flags;\n"
                             "\n"
                             "// uniform mat4 modelViewProjection;\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   flags = stepsFlag;\n"
                             "   gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "}\n"
;
const char* printergrid_cx_fragment = 
                             "#version 150 core\n"
                             " \n"
                             "out vec4 fragColor;\n"
                             "flat in vec2 flag;\n"
                             "uniform float visible;\n"
                             "uniform vec4 xshowcolor;\n"
                             "uniform vec4 yshowcolor;\n"
                             "uniform vec4 linecolor;\n"
                             "uniform vec4 xyIndexcolor;\n"
                             "uniform float highlight_index_x = 3.0;\n"
                             "uniform float highlight_index_y = 3.0;\n"
                             "void main() \n"
                             "{\n"
                             "	if(int(flag.x) == 0)\n"
                             "	{\n"
                             "		fragColor = yshowcolor;\n"
                             "	}\n"
                             "	else if(int(flag.y) == 0)\n"
                             "	{\n"
                             "		fragColor = xshowcolor;\n"
                             "	}\n"
                             "	else\n"
                             "	{\n"
                             "		if(int(highlight_index_x) == int(flag.x) || int(highlight_index_y) == int(flag.y))\n"
                             "		{\n"
                             "			fragColor = xyIndexcolor;\n"
                             "		}\n"
                             "		else\n"
                             "		{\n"
                             "			fragColor = linecolor;\n"
                             "		}\n"
                             "	}\n"
                             "}\n"
;
const char* printergrid_cx_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec2 vertexFlag;\n"
                             "uniform mat4 modelViewProjection;\n"
                             "\n"
                             "flat out vec2 flag;\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "   flag = vertexFlag;\n"
                             "}\n"
;
const char* pure_fragment = 
                             "#version 150 core\n"
                             " \n"
                             "out vec4 fragColor;\n"
                             "uniform vec4 color;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	fragColor = color;\n"
                             "}\n"
;
const char* pure_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "}\n"
;
const char* rendertoframebuffer_fragment = 
                             "#version 150 core\n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	fragColor = vec4(1.0);\n"
                             "}\n"
;
const char* rendertoframebuffer_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "uniform vec4 layoutRect;\n"
                             "uniform int mirrorType;\n"
                             "\n"
                             "void main()\n"
                             "{\n"
                             "	vec2 project = (vertexPosition.xy - layoutRect.xy) / layoutRect.zw * 2.0 - 1.0;\n"
                             "	\n"
                             "	if(0 == mirrorType)  //normal type\n"
                             "		gl_Position = vec4(project.x, -project.y, 0.0, 1.0);\n"
                             "	else if(1 == mirrorType) //mirror_x\n"
                             "		gl_Position = vec4(project.x, project.y, 0.0, 1.0);\n"
                             "	else if(2 == mirrorType) //mirror_y\n"
                             "		gl_Position = vec4(-project.x, -project.y, 0.0, 1.0);\n"
                             "}\n"
;
const char* sceneindicator_fragment = 
                             "#version 330 core\n"
                             "\n"
                             "layout (location = 0) out vec4 fragColor;\n"
                             "\n"
                             "in vec2 texCoord;\n"
                             "in float dirIndex;\n"
                             "in vec3 normal;\n"
                             "\n"
                             "uniform sampler2D colorMap;\n"
                             "uniform sampler2D selectMap;\n"
                             "\n"
                             "uniform float diffuseLowerLimit = 0.6;\n"
                             "uniform float diffuseUpperLimit = 1.1;\n"
                             "\n"
                             "uniform float highlightFaces;\n"
                             "\n"
                             "void main() \n"
                             "{	\n"
                             "	float diffuse = dot(normalize(normal), normalize(vec3(1.0, 1.0, 1.0)));\n"
                             "	diffuse = clamp(diffuse, 0.0, 1.0);\n"
                             "	diffuse = mix(diffuseLowerLimit, diffuseUpperLimit, diffuse);\n"
                             "\n"
                             "	vec4 texColor = texture(colorMap, texCoord);\n"
                             "\n"
                             "	if (abs(highlightFaces - dirIndex) < 0.0001) {\n"
                             "		texColor = texture(selectMap, texCoord);\n"
                             "	}\n"
                             "\n"
                             "	fragColor = vec4(texColor.rgb * diffuse, 1.0);\n"
                             "} \n"
;
const char* sceneindicator_vert = 
                             "#version 330 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "in vec2 vertexTexCoord;\n"
                             "in float facesIndex;\n"
                             "\n"
                             "out vec2 texCoord;\n"
                             "out float dirIndex;\n"
                             "out vec3 normal;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "uniform mat4 viewportMatrix;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   texCoord = vertexTexCoord;\n"
                             "   dirIndex = facesIndex;\n"
                             "   \n"
                             "   gl_Position = viewportMatrix * projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "\n"
                             "   normal = mat3(viewMatrix * modelMatrix ) * vertexNormal;\n"
                             "   // gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "\n"
                             "}\n"
;
const char* splitplane_fragment = 
                             "#version 150 core\n"
                             "\n"
                             "in vec4 clip; \n"
                             "in vec3 worldPosition;\n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "\n"
                             "uniform vec3 globalNormal;\n"
                             "uniform vec4 color;\n"
                             "uniform sampler2D depthTexture;\n"
                             "uniform sampler2D positionTexture;\n"
                             "uniform sampler2D normalTexture;\n"
                             "uniform sampler2D faceTexture;\n"
                             "uniform ivec2 faceRange;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	vec3 ndc = clip.xyz / clip.w;\n"
                             "   	ndc = ndc * 0.5 + 0.5;\n"
                             "	vec2 uv = ndc.xy;\n"
                             "\n"
                             "	// float d = texture(depthTexture, ndc.xy).x;\n"
                             "\n"
                             "	// float currentDepth = ndc.z;\n"
                             "\n"
                             "	// float threshold = 0.005;\n"
                             "\n"
                             "	// float k = smoothstep(0.0, threshold, abs(d - currentDepth));\n"
                             "	// k = pow(1.0-k, 150.0);\n"
                             "\n"
                             "	// fragColor = vec4(color.rgb, color.a + k);\n"
                             "\n"
                             "	//两个面法线越接近，阈值越小\n"
                             "	vec3 dstNormal = texture(normalTexture, uv).xyz;\n"
                             "	float factor = dot(normalize(dstNormal), normalize(globalNormal));\n"
                             "	factor = max(1.0 - abs(factor), 0.3);\n"
                             "	float threshold = 10.0 * factor;\n"
                             "\n"
                             "	vec3 dstPosition = texture(positionTexture, uv).xyz;\n"
                             "	float length = distance(dstPosition, worldPosition);\n"
                             "	float k = smoothstep(0.0, threshold, length);\n"
                             "	k = pow(1.0-k, 100.0);\n"
                             "\n"
                             "	//排除非当前选中模型\n"
                             "	vec4 codedFace = texture(faceTexture, uv);\n"
                             "	codedFace *= 255.0;\n"
                             "	float faceId = (16777216.0 * codedFace.a + 65536.0 * codedFace.b + 256.0 * codedFace.g + codedFace.r);\n"
                             "	// if (faceRange.x <= faceId && faceId < faceRange.x+faceRange.y) {\n"
                             "	// } else {\n"
                             "	// 	k = 0.0;\n"
                             "	// }\n"
                             "	float isTarget = step(float(faceRange.x), faceId);\n"
                             "	isTarget *= step(faceId, float( faceRange.x+faceRange.y));\n"
                             "	k *= isTarget;\n"
                             "\n"
                             "	fragColor = vec4(color.rgb, color.a + k);\n"
                             "}\n"
;
const char* splitplane_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "out vec4 clip; \n"
                             "out vec3 worldPosition;\n"
                             "\n"
                             "uniform mat4 modelViewProjection;\n"
                             "uniform mat4 modelMatrix;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   worldPosition = (modelMatrix * vec4(vertexPosition, 1.0)).xyz;\n"
                             "   clip = modelViewProjection * vec4(vertexPosition, 1.0);\n"
                             "   gl_Position = clip;\n"
                             "\n"
                             "}\n"
;
const char* support_fragment = 
                             "#version 150 core\n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "in vec3 worldPosition;\n"
                             "flat in float flag;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "uniform vec4 diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 stateColors[6];\n"
                             "\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "uniform float bottom; \n"
                             "uniform float topVisibleHeight = 100000.0;\n"
                             "uniform float bottomVisibleHeight = -10000.0;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    vec4 color = stateColors[int(flag)];\n"
                             "//    color.a = flag;\n"
                             "\n"
                             "	if(worldPosition.z < bottomVisibleHeight || worldPosition.z > topVisibleHeight)\n"
                             "		discard;\n"
                             "	\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	vec4 specular_color   = specular;\n"
                             "	\n"
                             "	float NdotL 		  = dot(fnormal, lightDirection);\n"
                             "	vec4 ambientColor 	  = ambient * color;\n"
                             "	vec3 freflection      = normalize(((2.0 * fnormal) * NdotL) - lightDirection);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	vec4 diffuseColor     = NdotL * diffuse * color;\n"
                             "	vec4 specularColor    = specular * pow( RdotV, specularPower);\n"
                             "	vec4 coreColor = ambientColor + diffuseColor + specularColor;\n"
                             "	\n"
                             "    if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < minSpace.z || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "	{\n"
                             "		coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "	}\n"
                             "	\n"
                             "//        if( abs(worldPosition.z - bottom) < 0.01 )\n"
                             "//        {\n"
                             "//                coreColor.g += 0.4;\n"
                             "//        }\n"
                             "	\n"
                             "        fragmentColor = vec4(coreColor.rgb, color.a);\n"
                             "}\n"
;
const char* support_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "in float vertexFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec3 worldPosition;\n"
                             "flat out float flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "	flag			= vertexFlag;\n"
                             "	\n"
                             "	if(vertexFlag == 0.0)\n"
                             "	{\n"
                             "		gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "	}\n"
                             "}\n"
;
const char* support_dlp_fragment = 
                             "#version 150 core \n"
                             "out vec4 fragmentColor;\n"
                             "\n"
                             "in vec3 viewDirection;\n"
                             "in vec3 normal;\n"
                             "in vec3 worldPosition;\n"
                             "flat in float flag;\n"
                             "\n"
                             "uniform vec4 ambient = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "uniform vec4 diffuse = vec4(1.0, 1.0, 1.0, 1.0);\n"
                             "uniform vec4 specular = vec4(0.125, 0.125, 0.125, 1.0);\n"
                             "uniform float specularPower = 12.0;\n"
                             "\n"
                             "uniform vec3 lightDirection = vec3(0.0, 0.0, 1.0);\n"
                             "\n"
                             "uniform vec4 clipPlane1;\n"
                             "uniform vec4 clipPlane2;\n"
                             "\n"
                             "uniform int checkScope = 1;\n"
                             "uniform vec3 minSpace;\n"
                             "uniform vec3 maxSpace;\n"
                             "\n"
                             "uniform int cameraDir;\n"
                             "\n"
                             "uniform vec4 stateColors[6];\n"
                             "\n"
                             "\n"
                             "float distance2Plane(vec3 position, vec4 plane)\n"
                             "{\n"
                             "	vec3 p = position - vec3(0.0, 0.0, plane.w);\n"
                             "	return dot(p, plane.xyz);\n"
                             "}\n"
                             "\n"
                             "vec4 directLight(vec3 light_dir, vec3 fnormal, vec4 core_color, vec4 ambient_color, vec4 diffuse_color, vec4 specular_color)\n"
                             "{\n"
                             "	float NdotL 		  = max(dot(fnormal, light_dir), 0.0);\n"
                             "	ambient_color 	  	  = ambient_color * core_color;\n"
                             "\n"
                             "	vec3 freflection      = reflect(-light_dir, fnormal);\n"
                             "	vec3 fViewDirection   = normalize(viewDirection);\n"
                             "	float RdotV           = max(0.0, dot(freflection, fViewDirection)); \n"
                             "	\n"
                             "	diffuse_color		  = NdotL * diffuse_color * core_color;\n"
                             "	specular_color        = specular_color * pow( RdotV, specularPower) * core_color;\n"
                             "	\n"
                             "	return ambient_color + diffuse_color + specular_color;\n"
                             "}\n"
                             " \n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	if(cameraDir == 0)\n"
                             "		discard;\n"
                             "		\n"
                             "	if(distance2Plane(worldPosition, clipPlane1) < 0.0)\n"
                             "		discard;\n"
                             "\n"
                             "	if(distance2Plane(worldPosition, clipPlane2) < 0.0)\n"
                             "		discard;\n"
                             "		\n"
                             "    vec4 color = stateColors[int(flag)];\n"
                             "\n"
                             "	vec3 fnormal 		  =	normalize(normal);\n"
                             "	\n"
                             "	vec3 lightDir = normalize(lightDirection);\n"
                             "	vec4 coreColor = directLight(lightDir, fnormal, color, ambient, diffuse, specular);\n"
                             "	\n"
                             "	if(checkScope > 0)\n"
                             "	{\n"
                             "		if(worldPosition.x < minSpace.x || worldPosition.y < minSpace.y || worldPosition.z < 0.1 || worldPosition.x > maxSpace.x || worldPosition.y > maxSpace.y || worldPosition.z > maxSpace.z)\n"
                             "		{\n"
                             "			coreColor *= 0.3;\n"
                             "			coreColor.r += 0.6;\n"
                             "		}\n"
                             "	}\n"
                             "	\n"
                             "    fragmentColor = vec4(coreColor.rgb, color.a);\n"
                             "}\n"
;
const char* support_dlp_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "in vec3 vertexNormal;\n"
                             "in float vertexFlag;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "out vec3 viewDirection;\n"
                             "out vec3 normal;\n"
                             "out vec3 worldPosition;\n"
                             "flat out float flag;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	mat4 modelViewMatrix = viewMatrix * modelMatrix;\n"
                             "	vec4 tworldPosition = modelViewMatrix * vec4(vertexPosition, 1.0);\n"
                             "    gl_Position = projectionMatrix *  tworldPosition;\n"
                             "	\n"
                             "	viewDirection  = normalize(vec3(-tworldPosition));\n"
                             "	mat3 normalMatrix = mat3(modelViewMatrix);\n"
                             "	\n"
                             "    normal          = normalMatrix * vertexNormal;\n"
                             "	worldPosition   = vec3(modelMatrix * vec4(vertexPosition, 1.0));\n"
                             "	flag			= vertexFlag;\n"
                             "	\n"
                             "	if(vertexFlag == 0.0)\n"
                             "	{\n"
                             "		gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n"
                             "	}\n"
                             "}\n"
;
const char* surfacequad_fragment = 
                             "#version 150 core \n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "uniform vec4 color = vec4(1.0, 0.0, 0.0, 1.0);\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "	fragColor = color;\n"
                             "}\n"
;
const char* surfacequad_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "void main() \n"
                             "{\n"
                             "   gl_Position = vec4(vertexPosition.xy, -0.999, 1.0);\n"
                             "}\n"
;
const char* zproject_fragment = 
                             "#version 150 core \n"
                             "\n"
                             "out vec4 fragColor;\n"
                             "uniform vec4 color = vec4(0.2275, 0.2275, 0.2353, 0.5);\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "	fragColor = color;\n"
                             "}\n"
;
const char* zproject_vert = 
                             "#version 150 core\n"
                             "\n"
                             "in vec3 vertexPosition;\n"
                             "\n"
                             "uniform mat4 modelMatrix;\n"
                             "uniform mat4 viewMatrix;\n"
                             "uniform mat4 projectionMatrix;\n"
                             "\n"
                             "void main( void )\n"
                             "{\n"
                             "    vec4 tworldPosition = modelMatrix * vec4(vertexPosition, 1.0);\n"
                             "	tworldPosition.z = -0.01;\n"
                             "    gl_Position = projectionMatrix * viewMatrix *  tworldPosition;\n"
                             "}\n"
;
//-----------gl3.0 code array.
const char* shader_code_array[56] = {
	antialiasing_fragment,
	antialiasing_vert,
	blur_fragment,
	blur_vert,
	color_fragment,
	color_vert,
	gcodepreviewG_fragment,
	gcodepreviewG_geom,
	gcodepreviewG_vert,
	gpuantialiasing_fragment,
	gpuantialiasing_vert,
	modeldlp_fragment,
	modeldlp_geom,
	modeldlp_vert,
	modelface_fragment,
	modelface_vert,
	modelwire_fragment,
	modelwire_geom,
	modelwire_vert,
	modelwireframe_fragment,
	modelwireframe_geom,
	modelwireframe_vert,
	overlay_fragment,
	overlay_vert,
	phong_fragment,
	phong_vert,
	pickFace_fragment,
	pickFace_vert,
	pickFaceFlag_fragment,
	pickFaceFlag_vert,
	pickFace_pwd_fragment,
	pickFace_pwd_vert,
	pickindicator_fragment,
	pickindicator_vert,
	piefade_fragment,
	piefade_vert,
	pointInGcode_fragment,
	pointInGcode_vert,
	printergrid_cx_fragment,
	printergrid_cx_vert,
	pure_fragment,
	pure_vert,
	rendertoframebuffer_fragment,
	rendertoframebuffer_vert,
	sceneindicator_fragment,
	sceneindicator_vert,
	splitplane_fragment,
	splitplane_vert,
	support_fragment,
	support_vert,
	support_dlp_fragment,
	support_dlp_vert,
	surfacequad_fragment,
	surfacequad_vert,
	zproject_fragment,
	zproject_vert
};
//-------------programs!
struct ProgramDef
{
	const char* name;
	int vIndex;
    int tcsIndex;
    int tesIndex;
	int gIndex;
	int fIndex;
};
int programs_meta_size = 26;
ProgramDef programs_meta[26] = {
  { "antialiasing" , 1  ,  -1   ,  -1   ,  -1   , 0  },
   { "blur" , 3  ,  -1   ,  -1   ,  -1   , 2  },
   { "color" , 5  ,  -1   ,  -1   ,  -1   , 4  },
   { "gcodepreviewG" , 8  ,  -1   ,  -1   , 7  , 6  },
   { "gpuantialiasing" , 10  ,  -1   ,  -1   ,  -1   , 9  },
   { "modeldlp" , 13  ,  -1   ,  -1   , 12  , 11  },
   { "modelface" , 15  ,  -1   ,  -1   ,  -1   , 14  },
   { "modelwire" , 18  ,  -1   ,  -1   , 17  , 16  },
   { "modelwireframe" , 21  ,  -1   ,  -1   , 20  , 19  },
   { "overlay" , 23  ,  -1   ,  -1   ,  -1   , 22  },
   { "phong" , 25  ,  -1   ,  -1   ,  -1   , 24  },
   { "pickFace" , 27  ,  -1   ,  -1   ,  -1   , 26  },
   { "pickFaceFlag" , 29  ,  -1   ,  -1   ,  -1   , 28  },
   { "pickFace_pwd" , 31  ,  -1   ,  -1   ,  -1   , 30  },
   { "pickindicator" , 33  ,  -1   ,  -1   ,  -1   , 32  },
   { "piefade" , 35  ,  -1   ,  -1   ,  -1   , 34  },
   { "pointInGcode" , 37  ,  -1   ,  -1   ,  -1   , 36  },
   { "printergrid_cx" , 39  ,  -1   ,  -1   ,  -1   , 38  },
   { "pure" , 41  ,  -1   ,  -1   ,  -1   , 40  },
   { "rendertoframebuffer" , 43  ,  -1   ,  -1   ,  -1   , 42  },
   { "sceneindicator" , 45  ,  -1   ,  -1   ,  -1   , 44  },
   { "splitplane" , 47  ,  -1   ,  -1   ,  -1   , 46  },
   { "support" , 49  ,  -1   ,  -1   ,  -1   , 48  },
   { "support_dlp" , 51  ,  -1   ,  -1   ,  -1   , 50  },
   { "surfacequad" , 53  ,  -1   ,  -1   ,  -1   , 52  },
   { "zproject" , 55  ,  -1   ,  -1   ,  -1   , 54  },
 };
